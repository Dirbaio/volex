//! TypeScript code generator for volex schemas.

use std::fmt::Write;

use crate::schema::*;

pub fn generate(schema: &Schema) -> String {
    let generator = TypeScriptCodeGenerator::new(schema);
    generator.generate()
}

struct TypeScriptCodeGenerator<'a> {
    schema: &'a Schema,
    output: String,
}

impl<'a> TypeScriptCodeGenerator<'a> {
    fn new(schema: &'a Schema) -> Self {
        Self {
            schema,
            output: String::new(),
        }
    }

    fn generate(mut self) -> String {
        self.output.push_str("// Code generated by volex. DO NOT EDIT.\n");
        self.output.push_str("/* eslint-disable */\n\n");

        self.output.push_str("import * as __rt from \"volex\";\n");

        // Check if we have any services
        let has_services = self
            .schema
            .items
            .iter()
            .any(|item| matches!(&item.node, Item::Service(_)));
        if has_services {
            self.output.push_str("import * as __rpc from \"volex/rpc\";\n");
        }
        self.output.push('\n');

        for item in &self.schema.items {
            match &item.node {
                Item::Struct(s) => self.gen_struct(s),
                Item::Message(m) => self.gen_message(m),
                Item::Enum(e) => self.gen_enum(e),
                Item::Union(u) => self.gen_union(u),
                Item::Service(s) => self.gen_service(s),
            }
            self.output.push('\n');
        }

        self.output
    }

    fn ts_type(&self, ty: &Type) -> String {
        match ty {
            Type::Bool => "boolean".to_string(),
            Type::U8
            | Type::U16
            | Type::U32
            | Type::U64
            | Type::I8
            | Type::I16
            | Type::I32
            | Type::I64
            | Type::F32
            | Type::F64 => "number".to_string(),
            Type::String => "string".to_string(),
            Type::Array(inner) => format!("{}[]", self.ts_type(&inner.node)),
            Type::Map(k, v) => format!("Map<{}, {}>", self.ts_type(&k.node), self.ts_type(&v.node)),
            Type::Named(name) => name.clone(),
        }
    }

    fn ts_type_optional(&self, ty: &Type) -> String {
        format!("{} | null", self.ts_type(ty))
    }

    fn gen_struct(&mut self, s: &Struct) {
        writeln!(self.output, "export interface {} {{", s.name.node).unwrap();

        for field in &s.fields {
            let ty = if field.optional {
                self.ts_type_optional(&field.ty.node)
            } else {
                self.ts_type(&field.ty.node)
            };
            writeln!(self.output, "  {}: {};", field.name.node, ty).unwrap();
        }

        self.output.push_str("}\n\n");

        // Generate encode function
        writeln!(
            self.output,
            "export function encode{}(value: {}, buf: __rt.WriteBuf): void {{",
            s.name.node, s.name.node
        )
        .unwrap();

        // Handle optional fields - encode presence bits first
        let optional_fields: Vec<_> = s.fields.iter().filter(|f| f.optional).collect();
        if !optional_fields.is_empty() {
            self.output.push_str("  const presence: boolean[] = [");
            for (i, field) in optional_fields.iter().enumerate() {
                if i > 0 {
                    self.output.push_str(", ");
                }
                write!(self.output, "value.{} !== null", &field.name.node).unwrap();
            }
            self.output.push_str("];\n");
            self.output.push_str("  __rt.encodePresenceBits(presence, buf);\n\n");
        }

        // Encode each field
        for field in &s.fields {
            let field_name = &field.name.node;
            if field.optional {
                writeln!(self.output, "  if (value.{} !== null) {{", field_name).unwrap();
                self.encode_value(&format!("value.{}", field_name), &field.ty.node, 2);
                self.output.push_str("  }\n");
            } else {
                self.encode_value(&format!("value.{}", field_name), &field.ty.node, 1);
            }
        }

        self.output.push_str("}\n\n");

        // Generate decode function
        writeln!(
            self.output,
            "export function decode{}(buf: __rt.Buf): {} {{",
            s.name.node, s.name.node
        )
        .unwrap();

        // Handle optional fields - decode presence bits first
        if !optional_fields.is_empty() {
            writeln!(
                self.output,
                "  const presence = __rt.decodePresenceBits(buf, {});",
                optional_fields.len()
            )
            .unwrap();
            self.output.push('\n');
        }

        // Decode each field
        let mut presence_idx = 0;
        for field in &s.fields {
            let field_name = &field.name.node;
            if field.optional {
                writeln!(
                    self.output,
                    "  let {}: {} | null = null;",
                    field_name,
                    self.ts_type(&field.ty.node)
                )
                .unwrap();
                writeln!(self.output, "  if (presence[{}]) {{", presence_idx).unwrap();
                self.decode_value(&field_name, &field.ty.node, 2);
                self.output.push_str("  }\n");
                presence_idx += 1;
            } else {
                write!(
                    self.output,
                    "  const {}: {} = ",
                    field_name,
                    self.ts_type(&field.ty.node)
                )
                .unwrap();
                self.decode_value_inline(&field.ty.node);
                self.output.push_str(";\n");
            }
        }

        self.output.push_str("\n  return {");
        for (i, field) in s.fields.iter().enumerate() {
            if i > 0 {
                self.output.push_str(", ");
            }
            write!(self.output, "{}", &field.name.node).unwrap();
        }
        self.output.push_str("};\n");
        self.output.push_str("}\n");
    }

    fn gen_message(&mut self, m: &Message) {
        writeln!(self.output, "export interface {} {{", m.name.node).unwrap();

        for field in &m.fields {
            let ty = if field.optional {
                self.ts_type_optional(&field.ty.node)
            } else {
                self.ts_type(&field.ty.node)
            };
            writeln!(self.output, "  {}: {};", &field.name.node, ty).unwrap();
        }

        self.output.push_str("}\n\n");

        // Generate encode function
        writeln!(
            self.output,
            "export function encode{}(value: {}, buf: __rt.WriteBuf): void {{",
            m.name.node, m.name.node
        )
        .unwrap();

        // Sort fields by index for encoding in index order
        let mut sorted_fields: Vec<_> = m.fields.iter().collect();
        sorted_fields.sort_by_key(|f| f.index.node);

        for field in sorted_fields {
            let field_name = &field.name.node;
            let index = field.index.node;

            if field.optional {
                writeln!(self.output, "  if (value.{} !== null) {{", field_name).unwrap();
                self.encode_tagged_field(index, &format!("value.{}", field_name), &field.ty.node, 2);
                self.output.push_str("  }\n");
            } else {
                self.encode_tagged_field(index, &format!("value.{}", field_name), &field.ty.node, 1);
            }
        }

        self.output.push_str("  __rt.encodeTag(0, 0, buf);\n");
        self.output.push_str("}\n\n");

        // Generate decode function
        writeln!(
            self.output,
            "export function decode{}(buf: __rt.Buf): {} {{",
            m.name.node, m.name.node
        )
        .unwrap();

        // Declare all fields with null/default values
        for field in &m.fields {
            let field_name = &field.name.node;
            if field.optional {
                writeln!(
                    self.output,
                    "  let {}: {} | null = null;",
                    field_name,
                    self.ts_type(&field.ty.node)
                )
                .unwrap();
            } else {
                write!(self.output, "  let {}: {} = ", field_name, self.ts_type(&field.ty.node)).unwrap();
                self.write_default_value(&field.ty.node);
                self.output.push_str(";\n");
            }
        }

        self.output.push_str("\n  while (true) {\n");
        self.output
            .push_str("    const { index, wireType } = __rt.decodeTag(buf);\n");
        self.output.push_str("    if (index === 0) break;\n\n");
        self.output.push_str("    switch (index) {\n");

        for field in &m.fields {
            let field_name = &field.name.node;
            let index = field.index.node;
            writeln!(self.output, "      case {}: {{", index).unwrap();
            self.decode_tagged_field(&field_name, &field.ty.node, 4);
            self.output.push_str("        break;\n");
            self.output.push_str("      }\n");
        }

        self.output.push_str("      default:\n");
        self.output.push_str("        // Skip unknown field\n");
        self.output
            .push_str("        throw new Error(`Unknown field index ${index}`);\n");
        self.output.push_str("    }\n");
        self.output.push_str("  }\n");

        self.output.push_str("\n  return {");
        for (i, field) in m.fields.iter().enumerate() {
            if i > 0 {
                self.output.push_str(", ");
            }
            write!(self.output, "{}", &field.name.node).unwrap();
        }
        self.output.push_str("};\n");
        self.output.push_str("}\n");
    }

    fn gen_enum(&mut self, e: &Enum) {
        // Generate TypeScript union type
        write!(self.output, "export type {} = ", e.name.node).unwrap();
        for (i, variant) in e.variants.iter().enumerate() {
            if i > 0 {
                self.output.push_str(" | ");
            }
            write!(self.output, "\"{}\"", variant.name.node).unwrap();
        }
        self.output.push_str(";\n\n");

        // Generate encode function
        writeln!(
            self.output,
            "export function encode{}(value: {}, buf: __rt.WriteBuf): void {{",
            e.name.node, e.name.node
        )
        .unwrap();
        self.output.push_str("  switch (value) {\n");
        for variant in &e.variants {
            writeln!(self.output, "    case \"{}\":", variant.name.node).unwrap();
            writeln!(self.output, "      __rt.encodeU32({}, buf);", variant.index.node).unwrap();
            writeln!(self.output, "      break;").unwrap();
        }
        self.output.push_str("    default:\n");
        self.output
            .push_str("      throw new Error(`Unknown enum variant: ${value}`);\n");
        self.output.push_str("  }\n");
        self.output.push_str("}\n\n");

        // Generate decode function
        writeln!(
            self.output,
            "export function decode{}(buf: __rt.Buf): {} {{",
            e.name.node, e.name.node
        )
        .unwrap();
        self.output.push_str("  const v = __rt.decodeU32(buf);\n");
        self.output.push_str("  switch (v) {\n");
        for variant in &e.variants {
            writeln!(self.output, "    case {}:", variant.index.node).unwrap();
            writeln!(self.output, "      return \"{}\";", variant.name.node).unwrap();
        }
        self.output.push_str("    default:\n");
        self.output
            .push_str("      throw new Error(`Unknown enum variant: ${v}`);\n");
        self.output.push_str("  }\n");
        self.output.push_str("}\n");
    }

    fn gen_union(&mut self, u: &Union) {
        let union_name = &u.name.node;

        // Generate TypeScript discriminated union type
        write!(self.output, "export type {} = ", union_name).unwrap();
        for (i, variant) in u.variants.iter().enumerate() {
            if i > 0 {
                self.output.push_str(" | ");
            }
            if let Some(ref ty) = variant.ty {
                write!(
                    self.output,
                    "{{ $tag: \"{}\"; $value: {} }}",
                    variant.name.node,
                    self.ts_type(&ty.node)
                )
                .unwrap();
            } else {
                write!(self.output, "{{ $tag: \"{}\" }}", variant.name.node).unwrap();
            }
        }
        self.output.push_str(";\n\n");

        // Generate encode function
        writeln!(
            self.output,
            "export function encode{}(value: {}, buf: __rt.WriteBuf): void {{",
            union_name, union_name
        )
        .unwrap();
        self.output.push_str("  switch (value.$tag) {\n");

        for variant in &u.variants {
            let index = variant.index.node;
            writeln!(self.output, "    case \"{}\":", variant.name.node).unwrap();

            if let Some(ref ty) = variant.ty {
                self.encode_tagged_field(index, "(value as any).$value", &ty.node, 3);
            } else {
                writeln!(self.output, "      __rt.encodeTag({}, 7, buf);", index).unwrap();
            }
            writeln!(self.output, "      break;").unwrap();
        }

        self.output.push_str("    default:\n");
        self.output
            .push_str("      throw new Error(`Unknown union variant: ${(value as { $tag: string }).$tag}`);\n");
        self.output.push_str("  }\n");
        self.output.push_str("}\n\n");

        // Generate decode function
        writeln!(
            self.output,
            "export function decode{}(buf: __rt.Buf): {} {{",
            union_name, union_name
        )
        .unwrap();
        self.output
            .push_str("  const { index, wireType } = __rt.decodeTag(buf);\n");
        self.output.push_str("  switch (index) {\n");

        for variant in &u.variants {
            let index = variant.index.node;
            writeln!(self.output, "    case {}: {{", index).unwrap();

            if let Some(ref ty) = variant.ty {
                // Reuse decode_tagged_field logic which handles all wire types correctly
                write!(self.output, "      let value: {};", self.ts_type(&ty.node)).unwrap();
                self.output.push_str("\n");
                self.decode_tagged_field("value", &ty.node, 3);
                writeln!(
                    self.output,
                    "      return {{ $tag: \"{}\", $value: value }};",
                    variant.name.node
                )
                .unwrap();
            } else {
                writeln!(self.output, "      return {{ $tag: \"{}\" }};", variant.name.node).unwrap();
            }
            writeln!(self.output, "    }}").unwrap();
        }

        self.output.push_str("    default:\n");
        self.output
            .push_str("      throw new Error(`Unknown union variant: ${index}`);\n");
        self.output.push_str("  }\n");
        self.output.push_str("}\n");
    }

    fn encode_value(&mut self, value: &str, ty: &Type, indent: usize) {
        self.encode_value_depth(value, ty, indent, 0);
    }

    fn encode_value_depth(&mut self, value: &str, ty: &Type, indent: usize, depth: usize) {
        let spaces = "  ".repeat(indent);
        match ty {
            Type::Bool => writeln!(self.output, "{}__rt.encodeBool({}, buf);", spaces, value).unwrap(),
            Type::U8 => writeln!(self.output, "{}__rt.encodeU8({}, buf);", spaces, value).unwrap(),
            Type::U16 => writeln!(self.output, "{}__rt.encodeU16({}, buf);", spaces, value).unwrap(),
            Type::U32 => writeln!(self.output, "{}__rt.encodeU32({}, buf);", spaces, value).unwrap(),
            Type::U64 => writeln!(self.output, "{}__rt.encodeU64({}, buf);", spaces, value).unwrap(),
            Type::I8 => writeln!(self.output, "{}__rt.encodeI8({}, buf);", spaces, value).unwrap(),
            Type::I16 => writeln!(self.output, "{}__rt.encodeI16({}, buf);", spaces, value).unwrap(),
            Type::I32 => writeln!(self.output, "{}__rt.encodeI32({}, buf);", spaces, value).unwrap(),
            Type::I64 => writeln!(self.output, "{}__rt.encodeI64({}, buf);", spaces, value).unwrap(),
            Type::F32 => writeln!(self.output, "{}__rt.encodeF32({}, buf);", spaces, value).unwrap(),
            Type::F64 => writeln!(self.output, "{}__rt.encodeF64({}, buf);", spaces, value).unwrap(),
            Type::String => writeln!(self.output, "{}__rt.encodeString({}, buf);", spaces, value).unwrap(),
            Type::Array(inner) => {
                let item_var = format!("item{}", depth);
                writeln!(self.output, "{}__rt.encodeVarint({}.length, buf);", spaces, value).unwrap();
                writeln!(self.output, "{}for (const {} of {}) {{", spaces, item_var, value).unwrap();
                self.encode_value_depth(&item_var, &inner.node, indent + 1, depth + 1);
                writeln!(self.output, "{}}}", spaces).unwrap();
            }
            Type::Map(k, v) => {
                let key_var = format!("k{}", depth);
                let val_var = format!("v{}", depth);
                writeln!(self.output, "{}__rt.encodeVarint({}.size, buf);", spaces, value).unwrap();
                writeln!(
                    self.output,
                    "{}for (const [{}, {}] of {}) {{",
                    spaces, key_var, val_var, value
                )
                .unwrap();
                self.encode_value_depth(&key_var, &k.node, indent + 1, depth + 1);
                self.encode_value_depth(&val_var, &v.node, indent + 1, depth + 1);
                writeln!(self.output, "{}}}", spaces).unwrap();
            }
            Type::Named(name) => {
                writeln!(self.output, "{}encode{}({}, buf);", spaces, name, value).unwrap();
            }
        }
    }

    fn decode_value(&mut self, target: &str, ty: &Type, indent: usize) {
        let spaces = "  ".repeat(indent);
        write!(self.output, "{}{} = ", spaces, target).unwrap();
        self.decode_value_inline(ty);
        self.output.push_str(";\n");
    }

    fn decode_value_inline(&mut self, ty: &Type) {
        match ty {
            Type::Bool => write!(self.output, "__rt.decodeBool(buf)").unwrap(),
            Type::U8 => write!(self.output, "__rt.decodeU8(buf)").unwrap(),
            Type::U16 => write!(self.output, "__rt.decodeU16(buf)").unwrap(),
            Type::U32 => write!(self.output, "__rt.decodeU32(buf)").unwrap(),
            Type::U64 => write!(self.output, "__rt.decodeU64(buf)").unwrap(),
            Type::I8 => write!(self.output, "__rt.decodeI8(buf)").unwrap(),
            Type::I16 => write!(self.output, "__rt.decodeI16(buf)").unwrap(),
            Type::I32 => write!(self.output, "__rt.decodeI32(buf)").unwrap(),
            Type::I64 => write!(self.output, "__rt.decodeI64(buf)").unwrap(),
            Type::F32 => write!(self.output, "__rt.decodeF32(buf)").unwrap(),
            Type::F64 => write!(self.output, "__rt.decodeF64(buf)").unwrap(),
            Type::String => write!(self.output, "__rt.decodeString(buf)").unwrap(),
            Type::Array(inner) => {
                write!(self.output, "(() => {{ const count = Number(__rt.decodeVarint(buf)); const arr: {}[] = []; for (let i = 0; i < count; i++) {{ arr.push(", self.ts_type(&inner.node)).unwrap();
                self.decode_value_inline(&inner.node);
                write!(self.output, "); }} return arr; }})()").unwrap();
            }
            Type::Map(k, v) => {
                write!(
                    self.output,
                    "(() => {{ const count = Number(__rt.decodeVarint(buf)); const map = new Map<{}, {}>(); for (let i = 0; i < count; i++) {{ const k = ",
                    self.ts_type(&k.node),
                    self.ts_type(&v.node)
                )
                .unwrap();
                self.decode_value_inline(&k.node);
                write!(self.output, "; const v = ").unwrap();
                self.decode_value_inline(&v.node);
                write!(self.output, "; map.set(k, v); }} return map; }})()").unwrap();
            }
            Type::Named(name) => {
                write!(self.output, "decode{}(buf)", name).unwrap();
            }
        }
    }

    fn encode_tagged_field(&mut self, index: u32, value: &str, ty: &Type, indent: usize) {
        let spaces = "  ".repeat(indent);
        let wire_type = self.wire_type(ty);
        writeln!(self.output, "{}__rt.encodeTag({}, {}, buf);", spaces, index, wire_type).unwrap();

        if wire_type == 4 {
            // WireBytes - need to encode to temp buffer first
            writeln!(self.output, "{}{{", spaces).unwrap();
            writeln!(self.output, "{}  const tmpBuf = new __rt.WriteBuf();", spaces).unwrap();
            self.encode_value_to_buf(value, ty, indent + 1, "tmpBuf", true);
            writeln!(self.output, "{}  const bytes = tmpBuf.toUint8Array();", spaces).unwrap();
            writeln!(self.output, "{}  __rt.encodeVarint(bytes.length, buf);", spaces).unwrap();
            writeln!(self.output, "{}  buf.push(bytes);", spaces).unwrap();
            writeln!(self.output, "{}}}", spaces).unwrap();
        } else {
            self.encode_value(value, ty, indent);
        }
    }

    fn encode_value_to_buf(&mut self, value: &str, ty: &Type, indent: usize, buf_var: &str, in_bytes_field: bool) {
        self.encode_value_to_buf_depth(value, ty, indent, buf_var, in_bytes_field, 0);
    }

    fn encode_value_to_buf_depth(
        &mut self,
        value: &str,
        ty: &Type,
        indent: usize,
        buf_var: &str,
        in_bytes_field: bool,
        depth: usize,
    ) {
        let spaces = "  ".repeat(indent);
        match ty {
            Type::Bool => writeln!(self.output, "{}__rt.encodeBool({}, {});", spaces, value, buf_var).unwrap(),
            Type::U8 => writeln!(self.output, "{}__rt.encodeU8({}, {});", spaces, value, buf_var).unwrap(),
            Type::U16 => writeln!(self.output, "{}__rt.encodeU16({}, {});", spaces, value, buf_var).unwrap(),
            Type::U32 => writeln!(self.output, "{}__rt.encodeU32({}, {});", spaces, value, buf_var).unwrap(),
            Type::U64 => writeln!(self.output, "{}__rt.encodeU64({}, {});", spaces, value, buf_var).unwrap(),
            Type::I8 => writeln!(self.output, "{}__rt.encodeI8({}, {});", spaces, value, buf_var).unwrap(),
            Type::I16 => writeln!(self.output, "{}__rt.encodeI16({}, {});", spaces, value, buf_var).unwrap(),
            Type::I32 => writeln!(self.output, "{}__rt.encodeI32({}, {});", spaces, value, buf_var).unwrap(),
            Type::I64 => writeln!(self.output, "{}__rt.encodeI64({}, {});", spaces, value, buf_var).unwrap(),
            Type::F32 => writeln!(self.output, "{}__rt.encodeF32({}, {});", spaces, value, buf_var).unwrap(),
            Type::F64 => writeln!(self.output, "{}__rt.encodeF64({}, {});", spaces, value, buf_var).unwrap(),
            Type::String => {
                if in_bytes_field {
                    writeln!(
                        self.output,
                        "{}{}.push(new TextEncoder().encode({}));",
                        spaces, buf_var, value
                    )
                    .unwrap();
                } else {
                    writeln!(self.output, "{}__rt.encodeString({}, {});", spaces, value, buf_var).unwrap();
                }
            }
            Type::Array(inner) => {
                let item_var = format!("item{}", depth);
                // Only skip count if at top level AND elements are fixed-size.
                // Nested arrays always need a count prefix.
                let skip_count = in_bytes_field && self.schema.fixed_size(&inner.node).is_some();
                if skip_count {
                    writeln!(self.output, "{}for (const {} of {}) {{", spaces, item_var, value).unwrap();
                    self.encode_value_to_buf_depth(&item_var, &inner.node, indent + 1, buf_var, false, depth + 1);
                    writeln!(self.output, "{}}}", spaces).unwrap();
                } else {
                    writeln!(
                        self.output,
                        "{}__rt.encodeVarint({}.length, {});",
                        spaces, value, buf_var
                    )
                    .unwrap();
                    writeln!(self.output, "{}for (const {} of {}) {{", spaces, item_var, value).unwrap();
                    self.encode_value_to_buf_depth(&item_var, &inner.node, indent + 1, buf_var, false, depth + 1);
                    writeln!(self.output, "{}}}", spaces).unwrap();
                }
            }
            Type::Map(k, v) => {
                let key_var = format!("k{}", depth);
                let val_var = format!("v{}", depth);
                let key_fixed = self.schema.fixed_size(&k.node).is_some();
                let val_fixed = self.schema.fixed_size(&v.node).is_some();
                // Only skip count if at top level AND entries are fixed-size.
                // Nested maps always need a count prefix.
                let skip_count = in_bytes_field && key_fixed && val_fixed;
                if skip_count {
                    writeln!(
                        self.output,
                        "{}for (const [{}, {}] of {}) {{",
                        spaces, key_var, val_var, value
                    )
                    .unwrap();
                    self.encode_value_to_buf_depth(&key_var, &k.node, indent + 1, buf_var, false, depth + 1);
                    self.encode_value_to_buf_depth(&val_var, &v.node, indent + 1, buf_var, false, depth + 1);
                    writeln!(self.output, "{}}}", spaces).unwrap();
                } else {
                    writeln!(self.output, "{}__rt.encodeVarint({}.size, {});", spaces, value, buf_var).unwrap();
                    writeln!(
                        self.output,
                        "{}for (const [{}, {}] of {}) {{",
                        spaces, key_var, val_var, value
                    )
                    .unwrap();
                    self.encode_value_to_buf_depth(&key_var, &k.node, indent + 1, buf_var, false, depth + 1);
                    self.encode_value_to_buf_depth(&val_var, &v.node, indent + 1, buf_var, false, depth + 1);
                    writeln!(self.output, "{}}}", spaces).unwrap();
                }
            }
            Type::Named(name) => {
                writeln!(self.output, "{}encode{}({}, {});", spaces, name, value, buf_var).unwrap();
            }
        }
    }

    fn decode_tagged_field(&mut self, target: &str, ty: &Type, indent: usize) {
        let spaces = "  ".repeat(indent);
        let wire_type = self.wire_type(ty);

        if wire_type == 4 {
            // WireBytes - need to decode length first
            writeln!(self.output, "{}const length = Number(__rt.decodeVarint(buf));", spaces).unwrap();

            match ty {
                Type::String => {
                    // Length already read, decode the string bytes directly
                    writeln!(
                        self.output,
                        "{}const strBytes = buf.data.slice(buf.offset, buf.offset + length);",
                        spaces
                    )
                    .unwrap();
                    writeln!(self.output, "{}buf.offset += length;", spaces).unwrap();
                    writeln!(
                        self.output,
                        "{}{} = new TextDecoder().decode(strBytes);",
                        spaces, target
                    )
                    .unwrap();
                    return;
                }
                Type::Array(inner) => {
                    if let Some(elem_size) = self.schema.fixed_size(&inner.node) {
                        // Fixed-size elements
                        writeln!(self.output, "{}const count = length / {};", spaces, elem_size).unwrap();
                        writeln!(self.output, "{}{} = [];", spaces, target).unwrap();
                        writeln!(self.output, "{}for (let i = 0; i < count; i++) {{", spaces).unwrap();
                        write!(self.output, "{}  {}.push(", spaces, target).unwrap();
                        self.decode_value_inline(&inner.node);
                        writeln!(self.output, ");").unwrap();
                        writeln!(self.output, "{}}}", spaces).unwrap();
                        return;
                    } else {
                        // Variable-size elements
                        writeln!(
                            self.output,
                            "{}const arrCount = Number(__rt.decodeVarint(buf));",
                            spaces
                        )
                        .unwrap();
                        writeln!(self.output, "{}{} = [];", spaces, target).unwrap();
                        writeln!(self.output, "{}for (let i = 0; i < arrCount; i++) {{", spaces).unwrap();
                        write!(self.output, "{}  {}.push(", spaces, target).unwrap();
                        self.decode_value_inline(&inner.node);
                        writeln!(self.output, ");").unwrap();
                        writeln!(self.output, "{}}}", spaces).unwrap();
                        return;
                    }
                }
                Type::Map(k, v) => {
                    let key_fixed = self.schema.fixed_size(&k.node).is_some();
                    let val_fixed = self.schema.fixed_size(&v.node).is_some();

                    if key_fixed && val_fixed {
                        let key_size = self.schema.fixed_size(&k.node).unwrap();
                        let val_size = self.schema.fixed_size(&v.node).unwrap();
                        let entry_size = key_size + val_size;
                        writeln!(self.output, "{}const count = length / {};", spaces, entry_size).unwrap();
                        writeln!(self.output, "{}{} = new Map();", spaces, target).unwrap();
                        writeln!(self.output, "{}for (let i = 0; i < count; i++) {{", spaces).unwrap();
                        write!(self.output, "{}  const k = ", spaces).unwrap();
                        self.decode_value_inline(&k.node);
                        writeln!(self.output, ";").unwrap();
                        write!(self.output, "{}  const v = ", spaces).unwrap();
                        self.decode_value_inline(&v.node);
                        writeln!(self.output, ";").unwrap();
                        writeln!(self.output, "{}  {}.set(k, v);", spaces, target).unwrap();
                        writeln!(self.output, "{}}}", spaces).unwrap();
                        return;
                    } else {
                        writeln!(
                            self.output,
                            "{}const mapCount = Number(__rt.decodeVarint(buf));",
                            spaces
                        )
                        .unwrap();
                        writeln!(self.output, "{}{} = new Map();", spaces, target).unwrap();
                        writeln!(self.output, "{}for (let i = 0; i < mapCount; i++) {{", spaces).unwrap();
                        write!(self.output, "{}  const k = ", spaces).unwrap();
                        self.decode_value_inline(&k.node);
                        writeln!(self.output, ";").unwrap();
                        write!(self.output, "{}  const v = ", spaces).unwrap();
                        self.decode_value_inline(&v.node);
                        writeln!(self.output, ";").unwrap();
                        writeln!(self.output, "{}  {}.set(k, v);", spaces, target).unwrap();
                        writeln!(self.output, "{}}}", spaces).unwrap();
                        return;
                    }
                }
                _ => {}
            }
        }

        self.decode_value(target, ty, indent);
    }

    fn wire_type(&self, ty: &Type) -> u8 {
        match self.schema.wire_type(ty) {
            crate::schema::WireType::Fixed8 => 0,
            crate::schema::WireType::Varint => 1,
            crate::schema::WireType::Fixed32 => 2,
            crate::schema::WireType::Fixed64 => 3,
            crate::schema::WireType::Bytes => 4,
            crate::schema::WireType::Message => 5,
            crate::schema::WireType::Union => 6,
            crate::schema::WireType::Unit => 7,
        }
    }

    fn write_default_value(&mut self, ty: &Type) {
        match ty {
            Type::Bool => write!(self.output, "false").unwrap(),
            Type::U8
            | Type::U16
            | Type::U32
            | Type::U64
            | Type::I8
            | Type::I16
            | Type::I32
            | Type::I64
            | Type::F32
            | Type::F64 => write!(self.output, "0").unwrap(),
            Type::String => write!(self.output, "\"\"").unwrap(),
            Type::Array(_) => write!(self.output, "[]").unwrap(),
            Type::Map(_, _) => write!(self.output, "new Map()").unwrap(),
            Type::Named(_) => write!(self.output, "null as any").unwrap(),
        }
    }

    fn gen_service(&mut self, s: &Service) {
        let service_name = &s.name.node;

        // Generate the client class
        writeln!(self.output, "/** Client for the {} service. */", service_name).unwrap();
        writeln!(self.output, "export class {}Client {{", service_name).unwrap();
        writeln!(self.output, "  private base: __rpc.ClientBase;").unwrap();
        self.output.push('\n');

        // Constructor
        writeln!(
            self.output,
            "  /** Creates a new client for the {} service. */",
            service_name
        )
        .unwrap();
        writeln!(self.output, "  constructor(transport: __rpc.Transport) {{").unwrap();
        writeln!(self.output, "    this.base = new __rpc.ClientBase(transport);").unwrap();
        writeln!(self.output, "  }}").unwrap();
        self.output.push('\n');

        // Run method
        writeln!(
            self.output,
            "  /** Runs the client's receive loop. Must be spawned before making RPC calls. */"
        )
        .unwrap();
        writeln!(self.output, "  async run(): Promise<void> {{").unwrap();
        writeln!(self.output, "    return this.base.run();").unwrap();
        writeln!(self.output, "  }}").unwrap();
        self.output.push('\n');

        // Generate client methods
        for method in &s.methods {
            let method_name = &method.name.node;
            let request_type = self.ts_type(&method.request.node);
            let index = method.index.node;

            match &method.response.node {
                ServiceResponse::Unary(resp_ty) => {
                    let response_type = self.ts_type(resp_ty);

                    writeln!(self.output, "  /** Calls the {} method. */", method_name).unwrap();
                    writeln!(
                        self.output,
                        "  async {}(req: {}): Promise<{}> {{",
                        method_name, request_type, response_type
                    )
                    .unwrap();

                    // Encode the request
                    writeln!(self.output, "    const reqBuf = new __rt.WriteBuf();").unwrap();
                    self.encode_for_service("req", &method.request.node, 2, "reqBuf");

                    // Make the call
                    writeln!(
                        self.output,
                        "    const respBuf = await this.base.callUnary({}, reqBuf.toUint8Array());",
                        index
                    )
                    .unwrap();

                    // Decode the response
                    writeln!(self.output, "    const buf = new __rt.Buf(respBuf, 0);").unwrap();
                    self.decode_for_service(resp_ty, 2);
                    writeln!(self.output, "    return resp;").unwrap();
                    writeln!(self.output, "  }}").unwrap();
                    self.output.push('\n');
                }
                ServiceResponse::Stream(_resp_ty) => {
                    writeln!(
                        self.output,
                        "  /** Calls the {} method and returns a stream receiver. */",
                        method_name
                    )
                    .unwrap();
                    writeln!(
                        self.output,
                        "  async {}(req: {}): Promise<{}{}Stream> {{",
                        method_name,
                        request_type,
                        service_name,
                        to_pascal_case(method_name)
                    )
                    .unwrap();

                    // Encode the request
                    writeln!(self.output, "    const reqBuf = new __rt.WriteBuf();").unwrap();
                    self.encode_for_service("req", &method.request.node, 2, "reqBuf");

                    // Make the call
                    writeln!(
                        self.output,
                        "    const receiver = await this.base.callStream({}, reqBuf.toUint8Array());",
                        index
                    )
                    .unwrap();

                    writeln!(
                        self.output,
                        "    return new {}{}Stream(receiver);",
                        service_name,
                        to_pascal_case(method_name)
                    )
                    .unwrap();
                    writeln!(self.output, "  }}").unwrap();
                    self.output.push('\n');
                }
            }
        }

        writeln!(self.output, "}}").unwrap();
        self.output.push('\n');

        // Generate stream receiver classes for streaming methods
        for method in &s.methods {
            if let ServiceResponse::Stream(resp_ty) = &method.response.node {
                let method_name = &method.name.node;
                let response_type = self.ts_type(resp_ty);

                writeln!(self.output, "/** Stream receiver for the {} method. */", method_name).unwrap();
                writeln!(
                    self.output,
                    "export class {}{}Stream {{",
                    service_name,
                    to_pascal_case(method_name)
                )
                .unwrap();
                writeln!(self.output, "  private receiver: __rpc.StreamReceiver;").unwrap();
                self.output.push('\n');

                writeln!(self.output, "  constructor(receiver: __rpc.StreamReceiver) {{").unwrap();
                writeln!(self.output, "    this.receiver = receiver;").unwrap();
                writeln!(self.output, "  }}").unwrap();
                self.output.push('\n');

                writeln!(self.output, "  /** Receives the next item from the stream. */",).unwrap();
                writeln!(self.output, "  async recv(): Promise<{}> {{", response_type).unwrap();
                writeln!(self.output, "    const data = await this.receiver.recv();").unwrap();
                writeln!(self.output, "    const buf = new __rt.Buf(data, 0);").unwrap();
                self.decode_for_service(resp_ty, 2);
                writeln!(self.output, "    return resp;").unwrap();
                writeln!(self.output, "  }}").unwrap();
                self.output.push('\n');

                writeln!(self.output, "  /** Cancels the stream. */").unwrap();
                writeln!(self.output, "  async cancel(): Promise<void> {{").unwrap();
                writeln!(self.output, "    return this.receiver.cancel();").unwrap();
                writeln!(self.output, "  }}").unwrap();
                writeln!(self.output, "}}").unwrap();
                self.output.push('\n');
            }
        }
    }

    fn encode_for_service(&mut self, value: &str, ty: &Type, indent: usize, buf_var: &str) {
        let spaces = "  ".repeat(indent);
        match ty {
            Type::Named(name) => {
                writeln!(self.output, "{}encode{}({}, {});", spaces, name, value, buf_var).unwrap();
            }
            _ => {
                // For primitives, use the encode_value helper
                self.encode_value_to_buf(value, ty, indent, buf_var, false);
            }
        }
    }

    fn decode_for_service(&mut self, ty: &Type, indent: usize) {
        let spaces = "  ".repeat(indent);
        match ty {
            Type::Named(name) => {
                writeln!(self.output, "{}const resp = decode{}(buf);", spaces, name).unwrap();
            }
            _ => {
                write!(self.output, "{}const resp = ", spaces).unwrap();
                self.decode_value_inline(ty);
                self.output.push_str(";\n");
            }
        }
    }
}

fn to_pascal_case(s: &str) -> String {
    s.split('_')
        .map(|word| {
            let mut chars = word.chars();
            match chars.next() {
                None => String::new(),
                Some(first) => first.to_uppercase().collect::<String>() + chars.as_str(),
            }
        })
        .collect()
}
