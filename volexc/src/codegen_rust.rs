//! Code generator for volex schemas.

use std::collections::HashSet;
use std::fmt::Write;

use crate::schema::*;

/// Serde derive mode for generated Rust code.
#[derive(Debug, Clone, Copy, PartialEq, Eq, clap::ValueEnum)]
pub enum SerdeMode {
    /// Never generate serde derives
    Never,
    /// Always generate serde derives
    Always,
    /// Generate serde derives behind a feature flag
    Feature,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
enum DerivableTrait {
    Debug,
    Clone,
    Copy,
    PartialEq,
    Eq,
    Hash,
    Default,
}

pub fn generate(schema: &Schema, serde_mode: SerdeMode) -> String {
    let generator = CodeGenerator::new(schema, serde_mode);
    generator.generate()
}

struct CodeGenerator<'a> {
    schema: &'a Schema,
    output: String,
    serde_mode: SerdeMode,
    derive_checking: HashSet<(String, DerivableTrait)>,
}

impl<'a> CodeGenerator<'a> {
    fn new(schema: &'a Schema, serde_mode: SerdeMode) -> Self {
        Self {
            schema,
            output: String::new(),
            serde_mode,
            derive_checking: HashSet::new(),
        }
    }

    /// Escape Rust reserved keywords with r# prefix.
    fn rust_ident(name: &str) -> String {
        match name {
            "as" | "break" | "const" | "continue" | "crate" | "else" | "enum" | "extern"
            | "false" | "fn" | "for" | "if" | "impl" | "in" | "let" | "loop" | "match"
            | "mod" | "move" | "mut" | "pub" | "ref" | "return" | "self" | "Self" | "static"
            | "struct" | "super" | "trait" | "true" | "type" | "unsafe" | "use" | "where"
            | "while" | "async" | "await" | "dyn" | "abstract" | "become" | "box" | "do"
            | "final" | "macro" | "override" | "priv" | "typeof" | "unsized" | "virtual"
            | "yield" | "try" => format!("r#{}", name),
            _ => name.to_string(),
        }
    }

    fn generate(mut self) -> String {
        self.output.push_str("// Generated by volex. Do not edit.\n\n");
        self.output.push_str("#![allow(unused)]\n");
        self.output.push_str("use volex as __rt;\n");
        self.output.push_str("use __rt::Decode as _;\n");

        let has_services = self
            .schema
            .items
            .iter()
            .any(|item| matches!(&item.node, Item::Service(_)));
        if has_services {
            self.output.push_str("use __rt::rpc::ServerCall as _;\n");
        }
        self.output.push('\n');

        for item in &self.schema.items {
            match &item.node {
                Item::Struct(s) => self.gen_struct(s),
                Item::Message(m) => self.gen_message(m),
                Item::Enum(e) => self.gen_enum(e),
                Item::Union(u) => self.gen_union(u),
                Item::Service(s) => self.gen_service(s),
            }
            self.output.push('\n');
        }

        self.output
    }

    fn rust_type(&self, ty: &Type) -> String {
        match ty {
            Type::Bool => "bool".to_string(),
            Type::U8 => "u8".to_string(),
            Type::U16 => "u16".to_string(),
            Type::U32 => "u32".to_string(),
            Type::U64 => "u64".to_string(),
            Type::I8 => "i8".to_string(),
            Type::I16 => "i16".to_string(),
            Type::I32 => "i32".to_string(),
            Type::I64 => "i64".to_string(),
            Type::F32 => "f32".to_string(),
            Type::F64 => "f64".to_string(),
            Type::String => "::std::string::String".to_string(),
            Type::Array(inner) => format!("::std::vec::Vec<{}>", self.rust_type(&inner.node)),
            Type::Map(k, v) => {
                format!(
                    "::std::collections::HashMap<{}, {}>",
                    self.rust_type(&k.node),
                    self.rust_type(&v.node)
                )
            }
            Type::Named(name) => name.clone(),
        }
    }

    /// Returns true if the item can derive the specified trait.
    fn can_derive_item(&mut self, item: &Item, trait_: DerivableTrait) -> bool {
        match item {
            Item::Struct(i) => i.fields.iter().all(|f| self.can_derive(&f.ty.node, trait_)),
            Item::Message(i) => i.fields.iter().all(|f| self.can_derive(&f.ty.node, trait_)),
            Item::Union(i) => i
                .variants
                .iter()
                .flat_map(|x| &x.node.ty)
                .all(|ty| self.can_derive(ty, trait_)),
            Item::Enum(_) => true,
            Item::Service(_) => unreachable!(),
        }
    }

    /// Returns true if the type can derive the specified trait.
    fn can_derive(&mut self, ty: &Type, trait_: DerivableTrait) -> bool {
        match ty {
            Type::Bool
            | Type::U8
            | Type::U16
            | Type::U32
            | Type::U64
            | Type::I8
            | Type::I16
            | Type::I32
            | Type::I64 => true,
            Type::F32 | Type::F64 => match trait_ {
                DerivableTrait::Eq | DerivableTrait::Hash => false,
                _ => true,
            },
            Type::String => match trait_ {
                DerivableTrait::Copy => false,
                _ => true,
            },
            Type::Array(t) => match trait_ {
                DerivableTrait::Copy => false,
                _ => self.can_derive(t, trait_),
            },
            Type::Map(k, v) => match trait_ {
                DerivableTrait::Copy => false,
                DerivableTrait::Hash => false,
                _ => self.can_derive(k, trait_) && self.can_derive(v, trait_),
            },
            Type::Named(name) => {
                let key = (name.clone(), trait_);
                if !self.derive_checking.insert(key.clone()) {
                    // Cycle detected: assume derivable (container types already handle Copy/Hash restrictions)
                    return true;
                }
                let result = self.can_derive_item(self.schema.item(name).unwrap(), trait_);
                self.derive_checking.remove(&key);
                result
            }
        }
    }

    /// Generates a #[derive(...)] attribute.
    fn gen_derive_attr(&mut self, item: &Item) {
        let mut derivable_traits = Vec::new();
        for trait_ in [
            DerivableTrait::Debug,
            DerivableTrait::Copy,
            DerivableTrait::Clone,
            DerivableTrait::PartialEq,
            DerivableTrait::Eq,
            DerivableTrait::Hash,
            DerivableTrait::Default,
        ] {
            // unions generate a Default impl manually.
            if trait_ == DerivableTrait::Default && matches!(item, Item::Union(_)) {
                continue;
            }

            if self.can_derive_item(item, trait_) {
                let trait_name = match trait_ {
                    DerivableTrait::Debug => "Debug",
                    DerivableTrait::Clone => "Clone",
                    DerivableTrait::Copy => "Copy",
                    DerivableTrait::PartialEq => "PartialEq",
                    DerivableTrait::Eq => "Eq",
                    DerivableTrait::Hash => "Hash",
                    DerivableTrait::Default => "Default",
                };
                derivable_traits.push(trait_name);
            }
        }

        if !derivable_traits.is_empty() {
            write!(self.output, "#[derive({})]", derivable_traits.join(", ")).unwrap();
            self.output.push('\n');
        }
    }

    fn gen_serde_derive(&mut self) {
        match self.serde_mode {
            SerdeMode::Never => {}
            SerdeMode::Always => {
                self.output
                    .push_str("#[derive(serde::Serialize, serde::Deserialize)]\n");
            }
            SerdeMode::Feature => {
                self.output
                    .push_str("#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n");
            }
        }
    }

    fn gen_serde_union_attr(&mut self) {
        match self.serde_mode {
            SerdeMode::Never => {}
            SerdeMode::Always => {
                self.output.push_str("#[serde(tag = \"$tag\", content = \"$value\")]\n");
            }
            SerdeMode::Feature => {
                self.output
                    .push_str("#[cfg_attr(feature = \"serde\", serde(tag = \"$tag\", content = \"$value\"))]\n");
            }
        }
    }

    fn gen_struct(&mut self, s: &Struct) {
        let name = &s.name.node;

        // Generate struct definition
        self.gen_derive_attr(&Item::Struct(s.clone()));
        self.gen_serde_derive();
        writeln!(self.output, "pub struct {} {{", name).unwrap();
        for field in &s.fields {
            let field_name = Self::rust_ident(&field.name.node);
            let field_type = self.rust_type(&field.ty.node);
            if field.optional {
                writeln!(
                    self.output,
                    "    pub {}: ::core::option::Option<{}>,",
                    field_name, field_type
                )
                .unwrap();
            } else {
                writeln!(self.output, "    pub {}: {},", field_name, field_type).unwrap();
            }
        }
        writeln!(self.output, "}}").unwrap();
        self.output.push('\n');

        // Count optional fields
        let optional_fields: Vec<_> = s.fields.iter().filter(|f| f.optional).collect();
        let has_optionals = !optional_fields.is_empty();
        let buf_param = if s.fields.is_empty() { "_buf" } else { "buf" };

        // Generate Encode impl
        writeln!(self.output, "impl __rt::Encode for {} {{", name).unwrap();
        writeln!(
            self.output,
            "    fn encode(&self, {}: &mut ::std::vec::Vec<u8>) {{",
            buf_param
        )
        .unwrap();

        if has_optionals {
            // Encode presence bits
            write!(self.output, "        __rt::encode_presence_bits(&[").unwrap();
            for (i, field) in optional_fields.iter().enumerate() {
                if i > 0 {
                    write!(self.output, ", ").unwrap();
                }
                write!(self.output, "self.{}.is_some()", Self::rust_ident(&field.name.node)).unwrap();
            }
            writeln!(self.output, "], buf);").unwrap();
        }

        // Encode fields in order
        for field in &s.fields {
            let field_name = Self::rust_ident(&field.name.node);
            if field.optional {
                writeln!(
                    self.output,
                    "        if let Some(ref v) = self.{} {{ __rt::Encode::encode(v, buf); }}",
                    field_name
                )
                .unwrap();
            } else {
                writeln!(self.output, "        __rt::Encode::encode(&self.{}, buf);", field_name).unwrap();
            }
        }

        writeln!(self.output, "    }}").unwrap();
        writeln!(self.output, "}}").unwrap();
        self.output.push('\n');

        // Generate Decode impl
        writeln!(self.output, "impl __rt::Decode for {} {{", name).unwrap();
        writeln!(
            self.output,
            "    fn decode({}: &mut &[u8]) -> ::core::result::Result<Self, __rt::DecodeError> {{",
            buf_param
        )
        .unwrap();

        if has_optionals {
            writeln!(
                self.output,
                "        let presence = __rt::decode_presence_bits({}, buf)?;",
                optional_fields.len()
            )
            .unwrap();
        }

        // Decode fields in order
        let mut opt_idx = 0;
        for field in &s.fields {
            let field_name = Self::rust_ident(&field.name.node);
            let field_type = self.rust_type(&field.ty.node);
            if field.optional {
                writeln!(
                    self.output,
                    "        let {} = if presence[{}] {{ ::core::option::Option::Some(<{}>::decode(buf)?) }} else {{ ::core::option::Option::None }};",
                    field_name, opt_idx, field_type
                )
                .unwrap();
                opt_idx += 1;
            } else {
                writeln!(
                    self.output,
                    "        let {} = <{}>::decode(buf)?;",
                    field_name, field_type
                )
                .unwrap();
            }
        }

        writeln!(self.output, "        ::core::result::Result::Ok(Self {{").unwrap();
        for field in &s.fields {
            writeln!(self.output, "            {},", Self::rust_ident(&field.name.node)).unwrap();
        }
        writeln!(self.output, "        }})").unwrap();
        writeln!(self.output, "    }}").unwrap();
        writeln!(self.output, "}}").unwrap();
        self.output.push('\n');

        // Generate WireType impl (structs use BYTES)
        writeln!(self.output, "impl __rt::WireType for {} {{", name).unwrap();
        writeln!(self.output, "    const WIRE_TYPE: u8 = __rt::wire::BYTES;").unwrap();
        if let Some(size) = self.schema.struct_fixed_size(s) {
            writeln!(
                self.output,
                "    const FIXED_SIZE: ::core::option::Option<usize> = ::core::option::Option::Some({});",
                size
            )
            .unwrap();
        }
        writeln!(self.output, "}}").unwrap();
    }

    fn gen_message(&mut self, m: &Message) {
        let name = &m.name.node;

        // Generate struct definition
        self.gen_derive_attr(&Item::Message(m.clone()));
        self.gen_serde_derive();
        writeln!(self.output, "pub struct {} {{", name).unwrap();
        for field in &m.fields {
            let field_name = Self::rust_ident(&field.name.node);
            let field_type = self.rust_type(&field.ty.node);
            if field.optional {
                writeln!(
                    self.output,
                    "    pub {}: ::core::option::Option<{}>,",
                    field_name, field_type
                )
                .unwrap();
            } else {
                writeln!(self.output, "    pub {}: {},", field_name, field_type).unwrap();
            }
        }
        writeln!(self.output, "}}").unwrap();
        self.output.push('\n');

        // Generate Encode impl
        writeln!(self.output, "impl __rt::Encode for {} {{", name).unwrap();
        writeln!(self.output, "    fn encode(&self, buf: &mut ::std::vec::Vec<u8>) {{").unwrap();

        // Encode fields in index order
        let mut fields_sorted: Vec<_> = m.fields.iter().collect();
        fields_sorted.sort_by_key(|f| f.index.node);

        for field in &fields_sorted {
            let field_name = Self::rust_ident(&field.name.node);
            let index = field.index.node;
            if field.optional {
                writeln!(
                    self.output,
                    "        if let Some(ref v) = self.{} {{ __rt::encode_field({}, v, buf); }}",
                    field_name, index
                )
                .unwrap();
            } else {
                writeln!(
                    self.output,
                    "        __rt::encode_field({}, &self.{}, buf);",
                    index, field_name
                )
                .unwrap();
            }
        }

        writeln!(self.output, "        __rt::encode_message_end(buf);").unwrap();
        writeln!(self.output, "    }}").unwrap();
        writeln!(self.output, "}}").unwrap();
        self.output.push('\n');

        // Generate Decode impl
        writeln!(self.output, "impl __rt::Decode for {} {{", name).unwrap();
        writeln!(
            self.output,
            "    fn decode(buf: &mut &[u8]) -> ::core::result::Result<Self, __rt::DecodeError> {{"
        )
        .unwrap();
        writeln!(self.output, "        let mut result = Self::default();").unwrap();
        writeln!(
            self.output,
            "        while let ::core::option::Option::Some((index, wire_type)) = __rt::decode_tag(buf)? {{"
        )
        .unwrap();
        writeln!(self.output, "            match index {{").unwrap();

        for field in &m.fields {
            let field_name = Self::rust_ident(&field.name.node);
            let index = field.index.node;
            if field.optional {
                writeln!(
                    self.output,
                    "                {} => result.{} = ::core::option::Option::Some(__rt::decode_field(buf)?),",
                    index, field_name
                )
                .unwrap();
            } else {
                writeln!(
                    self.output,
                    "                {} => result.{} = __rt::decode_field(buf)?,",
                    index, field_name
                )
                .unwrap();
            }
        }

        writeln!(
            self.output,
            "                _ => __rt::skip_by_wire_type(wire_type, buf)?,"
        )
        .unwrap();
        writeln!(self.output, "            }}").unwrap();
        writeln!(self.output, "        }}").unwrap();
        writeln!(self.output, "        ::core::result::Result::Ok(result)").unwrap();
        writeln!(self.output, "    }}").unwrap();
        writeln!(self.output, "}}").unwrap();
        self.output.push('\n');

        // Generate WireType impl (messages use MESSAGE)
        writeln!(self.output, "impl __rt::WireType for {} {{", name).unwrap();
        writeln!(self.output, "    const WIRE_TYPE: u8 = __rt::wire::MESSAGE;").unwrap();
        writeln!(self.output, "}}").unwrap();
    }

    fn gen_enum(&mut self, e: &Enum) {
        let name = &e.name.node;

        // Generate enum definition
        self.gen_derive_attr(&Item::Enum(e.clone()));
        self.gen_serde_derive();
        writeln!(self.output, "pub enum {} {{", name).unwrap();
        for (i, variant) in e.variants.iter().enumerate() {
            if i == 0 {
                // first variant is the default.
                writeln!(self.output, "    #[default]").unwrap();
            }
            writeln!(self.output, "    {},", variant.name.node).unwrap();
        }
        writeln!(self.output, "}}").unwrap();
        self.output.push('\n');

        // Generate Encode impl
        writeln!(self.output, "impl __rt::Encode for {} {{", name).unwrap();
        writeln!(self.output, "    fn encode(&self, buf: &mut ::std::vec::Vec<u8>) {{").unwrap();
        writeln!(self.output, "        let index: u32 = match self {{").unwrap();
        for variant in &e.variants {
            writeln!(
                self.output,
                "            Self::{} => {},",
                variant.name.node, variant.index.node
            )
            .unwrap();
        }
        writeln!(self.output, "        }};").unwrap();
        writeln!(self.output, "        __rt::Encode::encode(&index, buf);").unwrap();
        writeln!(self.output, "    }}").unwrap();
        writeln!(self.output, "}}").unwrap();
        self.output.push('\n');

        // Generate Decode impl
        writeln!(self.output, "impl __rt::Decode for {} {{", name).unwrap();
        writeln!(
            self.output,
            "    fn decode(buf: &mut &[u8]) -> ::core::result::Result<Self, __rt::DecodeError> {{"
        )
        .unwrap();
        writeln!(self.output, "        let index = <u32>::decode(buf)?;").unwrap();
        writeln!(self.output, "        match index {{").unwrap();
        for variant in &e.variants {
            writeln!(
                self.output,
                "            {} => ::core::result::Result::Ok(Self::{}),",
                variant.index.node, variant.name.node
            )
            .unwrap();
        }
        writeln!(
            self.output,
            "            _ => ::core::result::Result::Err(__rt::DecodeError::UnknownEnumVariant(index)),"
        )
        .unwrap();
        writeln!(self.output, "        }}").unwrap();
        writeln!(self.output, "    }}").unwrap();
        writeln!(self.output, "}}").unwrap();
        self.output.push('\n');

        // Generate WireType impl (enums use VARINT)
        writeln!(self.output, "impl __rt::WireType for {} {{", name).unwrap();
        writeln!(self.output, "    const WIRE_TYPE: u8 = __rt::wire::VARINT;").unwrap();
        writeln!(self.output, "}}").unwrap();
    }

    fn gen_union(&mut self, u: &Union) {
        let name = &u.name.node;

        // Generate enum definition
        self.gen_derive_attr(&Item::Union(u.clone()));
        self.gen_serde_derive();
        self.gen_serde_union_attr();
        writeln!(self.output, "pub enum {} {{", name).unwrap();
        for variant in &u.variants {
            let variant_name = &variant.name.node;
            if let Some(ty) = &variant.ty {
                writeln!(self.output, "    {}({}),", variant_name, self.rust_type(&ty.node)).unwrap();
            } else {
                writeln!(self.output, "    {},", variant_name).unwrap();
            }
        }
        writeln!(self.output, "}}").unwrap();
        self.output.push('\n');

        // Generate Default impl (first variant)
        if let Some(first) = u.variants.first() {
            writeln!(self.output, "impl ::core::default::Default for {} {{", name).unwrap();
            writeln!(self.output, "    fn default() -> Self {{").unwrap();
            if first.ty.is_some() {
                writeln!(
                    self.output,
                    "        Self::{}(::core::default::Default::default())",
                    first.name.node
                )
                .unwrap();
            } else {
                writeln!(self.output, "        Self::{}", first.node.name.node).unwrap();
            }
            writeln!(self.output, "    }}").unwrap();
            writeln!(self.output, "}}").unwrap();
            self.output.push('\n');
        }

        // Generate Encode impl
        writeln!(self.output, "impl __rt::Encode for {} {{", name).unwrap();
        writeln!(self.output, "    fn encode(&self, buf: &mut ::std::vec::Vec<u8>) {{").unwrap();
        writeln!(self.output, "        match self {{").unwrap();
        for variant in &u.variants {
            let variant_name = &variant.name.node;
            let index = variant.index.node;
            if variant.ty.is_some() {
                writeln!(
                    self.output,
                    "            Self::{}(v) => __rt::encode_field({}, v, buf),",
                    variant_name, index
                )
                .unwrap();
            } else {
                // Unit variant: just encode tag with UNIT wire type
                let tag = (index << 3) | 7; // 7 = wire::UNIT
                writeln!(
                    self.output,
                    "            Self::{} => __rt::encode_leb128_u64({}, buf),",
                    variant_name, tag
                )
                .unwrap();
            }
        }
        writeln!(self.output, "        }}").unwrap();
        writeln!(self.output, "    }}").unwrap();
        writeln!(self.output, "}}").unwrap();
        self.output.push('\n');

        // Generate Decode impl
        writeln!(self.output, "impl __rt::Decode for {} {{", name).unwrap();
        writeln!(
            self.output,
            "    fn decode(buf: &mut &[u8]) -> ::core::result::Result<Self, __rt::DecodeError> {{"
        )
        .unwrap();
        writeln!(self.output, "        let tag = __rt::decode_leb128_u64(buf)?;").unwrap();
        writeln!(self.output, "        let index = (tag >> 3) as u32;").unwrap();
        writeln!(self.output, "        match index {{").unwrap();
        for variant in &u.variants {
            let variant_name = &variant.name.node;
            let index = variant.index.node;
            if variant.ty.is_some() {
                writeln!(
                    self.output,
                    "            {} => ::core::result::Result::Ok(Self::{}(__rt::decode_field(buf)?)),",
                    index, variant_name
                )
                .unwrap();
            } else {
                // Unit variant: nothing to decode (UNIT wire type has no payload)
                writeln!(
                    self.output,
                    "            {} => ::core::result::Result::Ok(Self::{}),",
                    index, variant_name
                )
                .unwrap();
            }
        }
        writeln!(
            self.output,
            "            _ => ::core::result::Result::Err(__rt::DecodeError::UnknownUnionVariant(index)),"
        )
        .unwrap();
        writeln!(self.output, "        }}").unwrap();
        writeln!(self.output, "    }}").unwrap();
        writeln!(self.output, "}}").unwrap();
        self.output.push('\n');

        // Generate WireType impl (unions use UNION)
        writeln!(self.output, "impl __rt::WireType for {} {{", name).unwrap();
        writeln!(self.output, "    const WIRE_TYPE: u8 = __rt::wire::UNION;").unwrap();
        writeln!(self.output, "}}").unwrap();
    }

    fn gen_service(&mut self, s: &Service) {
        let service_name = &s.name.node;

        // Generate the service trait
        writeln!(self.output, "/// Trait for implementing the {} service.", service_name).unwrap();
        writeln!(self.output, "pub trait {} {{", service_name).unwrap();
        for method in &s.methods {
            let method_name = &method.name.node;
            let request_type = self.rust_type(&method.request.node);
            match &method.response.node {
                ServiceResponse::Unary(resp_ty) => {
                    let response_type = self.rust_type(resp_ty);
                    writeln!(
                        self.output,
                        "    async fn {}(&self, req: {}) -> ::core::result::Result<{}, __rt::rpc::RpcError>;",
                        method_name, request_type, response_type
                    )
                    .unwrap();
                }
                ServiceResponse::Stream(resp_ty) => {
                    let response_type = self.rust_type(resp_ty);
                    writeln!(
                        self.output,
                        "    async fn {}(&self, req: {}, stream: __rt::rpc::StreamSender<{}>);",
                        method_name, request_type, response_type
                    )
                    .unwrap();
                }
            }
        }
        writeln!(self.output, "}}\n").unwrap();

        // Generate the server function
        writeln!(self.output, "/// Serves the {} service.", service_name).unwrap();
        writeln!(
            self.output,
            "pub async fn serve_{}<Tr: __rt::rpc::ServerTransport<Call: 'static>, T: {} + 'static>(transport: &Tr, impl_: ::std::rc::Rc<T>) -> ::core::result::Result<(), __rt::rpc::RpcError> {{",
            to_snake_case(service_name), service_name
        )
        .unwrap();
        writeln!(self.output, "    loop {{").unwrap();
        writeln!(self.output, "        let mut call = transport.accept().await?;").unwrap();
        writeln!(self.output, "        let impl_ = impl_.clone();").unwrap();
        writeln!(
            self.output,
            "        let cancel_rx = __rt::rpc::ServerCall::take_cancel_rx(&mut call);"
        )
        .unwrap();
        writeln!(
            self.output,
            "        __rt::rpc::spawn_cancellable(cancel_rx, async move {{"
        )
        .unwrap();
        writeln!(
            self.output,
            "        match __rt::rpc::ServerCall::method_index(&call) {{"
        )
        .unwrap();

        for method in &s.methods {
            let method_name = &method.name.node;
            let index = method.index.node;

            match &method.response.node {
                ServiceResponse::Unary(resp_ty) => {
                    writeln!(self.output, "            {} => {{", index).unwrap();
                    writeln!(
                        self.output,
                        "                let mut buf = __rt::rpc::ServerCall::payload(&call);"
                    )
                    .unwrap();
                    writeln!(
                        self.output,
                        "                let req = match <{}>::decode(&mut buf) {{",
                        self.rust_type(&method.request.node)
                    )
                    .unwrap();
                    writeln!(self.output, "                    ::core::result::Result::Ok(v) => v,").unwrap();
                    writeln!(self.output, "                    ::core::result::Result::Err(e) => {{").unwrap();
                    writeln!(
                        self.output,
                        "                        let _ = call.send_error(__rt::rpc::ERR_CODE_DECODE_ERROR, &format!(\"decode error: {{}}\", e)).await;"
                    )
                    .unwrap();
                    writeln!(self.output, "                        return;").unwrap();
                    writeln!(self.output, "                    }}").unwrap();
                    writeln!(self.output, "                }};").unwrap();
                    writeln!(self.output, "                match impl_.{}(req).await {{", method_name).unwrap();
                    writeln!(
                        self.output,
                        "                    ::core::result::Result::Ok(resp) => {{"
                    )
                    .unwrap();
                    writeln!(
                        self.output,
                        "                        let mut resp_buf = ::std::vec::Vec::new();"
                    )
                    .unwrap();
                    self.gen_encode_for_service("resp", resp_ty, 24, "resp_buf");
                    writeln!(
                        self.output,
                        "                        let _ = call.send_response(resp_buf).await;"
                    )
                    .unwrap();
                    writeln!(self.output, "                    }}").unwrap();
                    writeln!(self.output, "                    ::core::result::Result::Err(e) => {{").unwrap();
                    writeln!(
                        self.output,
                        "                        let _ = call.send_error(__rt::rpc::ERR_CODE_HANDLER_ERROR, &e.message).await;"
                    )
                    .unwrap();
                    writeln!(self.output, "                    }}").unwrap();
                    writeln!(self.output, "                }}").unwrap();
                    writeln!(self.output, "            }}").unwrap();
                }
                ServiceResponse::Stream(resp_ty) => {
                    writeln!(self.output, "            {} => {{", index).unwrap();
                    writeln!(
                        self.output,
                        "                let mut buf = __rt::rpc::ServerCall::payload(&call);"
                    )
                    .unwrap();
                    writeln!(
                        self.output,
                        "                let req = match <{}>::decode(&mut buf) {{",
                        self.rust_type(&method.request.node)
                    )
                    .unwrap();
                    writeln!(self.output, "                    ::core::result::Result::Ok(v) => v,").unwrap();
                    writeln!(self.output, "                    ::core::result::Result::Err(e) => {{").unwrap();
                    writeln!(
                        self.output,
                        "                        let _ = call.send_error(__rt::rpc::ERR_CODE_DECODE_ERROR, &format!(\"decode error: {{}}\", e)).await;"
                    )
                    .unwrap();
                    writeln!(self.output, "                        return;").unwrap();
                    writeln!(self.output, "                    }}").unwrap();
                    writeln!(self.output, "                }};").unwrap();
                    writeln!(
                        self.output,
                        "                let stream = __rt::rpc::StreamSender::<{}>::new(call.into_stream_sender());",
                        self.rust_type(resp_ty)
                    )
                    .unwrap();
                    writeln!(self.output, "                impl_.{}(req, stream).await;", method_name).unwrap();
                    writeln!(self.output, "            }}").unwrap();
                }
            }
        }

        writeln!(self.output, "            _ => {{").unwrap();
        writeln!(
            self.output,
            "                let _ = call.send_error(__rt::rpc::ERR_CODE_UNKNOWN_METHOD, \"unknown method\").await;"
        )
        .unwrap();
        writeln!(self.output, "            }}").unwrap();
        writeln!(self.output, "        }}").unwrap();
        writeln!(self.output, "        }});").unwrap();
        writeln!(self.output, "    }}").unwrap();
        writeln!(self.output, "}}\n").unwrap();

        // Generate the client struct
        writeln!(self.output, "/// Client for the {} service.", service_name).unwrap();
        writeln!(
            self.output,
            "pub struct {}Client<Tr: __rt::rpc::ClientTransport> {{",
            service_name
        )
        .unwrap();
        writeln!(self.output, "    transport: Tr,").unwrap();
        writeln!(self.output, "}}\n").unwrap();

        // Generate client impl
        writeln!(
            self.output,
            "impl<Tr: __rt::rpc::ClientTransport> {}Client<Tr> {{",
            service_name
        )
        .unwrap();

        // Constructor
        writeln!(
            self.output,
            "    /// Creates a new client for the {} service.",
            service_name
        )
        .unwrap();
        writeln!(self.output, "    pub fn new(transport: Tr) -> Self {{").unwrap();
        writeln!(self.output, "        Self {{ transport }}").unwrap();
        writeln!(self.output, "    }}\n").unwrap();

        // Generate client methods
        for method in &s.methods {
            let method_name = &method.name.node;
            let request_type = self.rust_type(&method.request.node);
            let index = method.index.node;

            match &method.response.node {
                ServiceResponse::Unary(resp_ty) => {
                    let response_type = self.rust_type(resp_ty);

                    writeln!(self.output, "    /// Calls the {} method.", method_name).unwrap();
                    writeln!(
                        self.output,
                        "    pub async fn {}(&self, req: {}) -> ::core::result::Result<{}, __rt::rpc::RpcError> {{",
                        method_name, request_type, response_type
                    )
                    .unwrap();

                    // Encode the request
                    writeln!(self.output, "        let mut req_buf = ::std::vec::Vec::new();").unwrap();
                    self.gen_encode_for_service("req", &method.request.node, 8, "req_buf");

                    // Make the call
                    writeln!(
                        self.output,
                        "        let resp_buf = self.transport.call_unary({}, req_buf).await?;",
                        index
                    )
                    .unwrap();

                    // Decode the response
                    writeln!(self.output, "        let mut buf = resp_buf.as_slice();").unwrap();
                    self.gen_decode_for_service(resp_ty, 8);
                    writeln!(self.output, "        ::core::result::Result::Ok(req)").unwrap();
                    writeln!(self.output, "    }}\n").unwrap();
                }
                ServiceResponse::Stream(resp_ty) => {
                    let response_type = self.rust_type(resp_ty);

                    writeln!(
                        self.output,
                        "    /// Calls the {} method and returns a stream receiver.",
                        method_name
                    )
                    .unwrap();
                    writeln!(
                        self.output,
                        "    pub async fn {}(&self, req: {}) -> ::core::result::Result<{}{}Stream, __rt::rpc::RpcError> {{",
                        method_name, request_type, service_name, to_pascal_case(method_name)
                    )
                    .unwrap();

                    // Encode the request
                    writeln!(self.output, "        let mut req_buf = ::std::vec::Vec::new();").unwrap();
                    self.gen_encode_for_service("req", &method.request.node, 8, "req_buf");

                    // Make the call
                    writeln!(
                        self.output,
                        "        let receiver = self.transport.call_stream({}, req_buf).await?;",
                        index
                    )
                    .unwrap();

                    writeln!(
                        self.output,
                        "        ::core::result::Result::Ok({}{}Stream {{ receiver, _phantom: ::core::marker::PhantomData }})",
                        service_name, to_pascal_case(method_name)
                    )
                    .unwrap();
                    writeln!(self.output, "    }}\n").unwrap();

                    // Generate client stream struct
                    writeln!(self.output, "}}  // End of {}Client impl\n", service_name).unwrap();

                    writeln!(self.output, "/// Stream receiver for the {} method.", method_name).unwrap();
                    writeln!(
                        self.output,
                        "pub struct {}{}Stream {{",
                        service_name,
                        to_pascal_case(method_name)
                    )
                    .unwrap();
                    writeln!(self.output, "    receiver: __rt::rpc::StreamReceiver,").unwrap();
                    writeln!(
                        self.output,
                        "    _phantom: ::core::marker::PhantomData<{}>,",
                        response_type
                    )
                    .unwrap();
                    writeln!(self.output, "}}\n").unwrap();

                    writeln!(
                        self.output,
                        "impl {}{}Stream {{",
                        service_name,
                        to_pascal_case(method_name)
                    )
                    .unwrap();
                    writeln!(self.output, "    /// Receives the next item from the stream.").unwrap();
                    writeln!(
                        self.output,
                        "    pub async fn recv(&mut self) -> ::core::result::Result<{}, __rt::rpc::RpcError> {{",
                        response_type
                    )
                    .unwrap();
                    writeln!(self.output, "        let data = self.receiver.recv().await?;").unwrap();
                    writeln!(self.output, "        let mut buf = data.as_slice();").unwrap();
                    self.gen_decode_for_service(resp_ty, 8);
                    writeln!(self.output, "        ::core::result::Result::Ok(req)").unwrap();
                    writeln!(self.output, "    }}").unwrap();
                    writeln!(self.output, "}}\n").unwrap();

                    // Re-open the client impl for the next method
                    writeln!(
                        self.output,
                        "impl<Tr: __rt::rpc::ClientTransport> {}Client<Tr> {{",
                        service_name
                    )
                    .unwrap();
                }
            }
        }

        writeln!(self.output, "}}").unwrap();
    }

    fn gen_decode_for_service(&mut self, ty: &Type, indent: usize) {
        let spaces = " ".repeat(indent);
        match ty {
            Type::Named(_) => {
                writeln!(
                    self.output,
                    "{}let req = <{}>::decode(&mut buf).map_err(|e| __rt::rpc::RpcError::decode(e))?;",
                    spaces,
                    self.rust_type(ty)
                )
                .unwrap();
            }
            _ => {
                writeln!(
                    self.output,
                    "{}let req = <{}>::decode(&mut buf).map_err(|e| __rt::rpc::RpcError::decode(e))?;",
                    spaces,
                    self.rust_type(ty)
                )
                .unwrap();
            }
        }
    }

    fn gen_encode_for_service(&mut self, value: &str, ty: &Type, indent: usize, buf_name: &str) {
        let spaces = " ".repeat(indent);
        writeln!(
            self.output,
            "{}<{} as __rt::Encode>::encode(&{}, &mut {});",
            spaces,
            self.rust_type(ty),
            value,
            buf_name
        )
        .unwrap();
    }
}

fn to_snake_case(s: &str) -> String {
    let mut result = String::new();
    for (i, c) in s.chars().enumerate() {
        if c.is_uppercase() {
            if i > 0 {
                result.push('_');
            }
            result.extend(c.to_lowercase());
        } else {
            result.push(c);
        }
    }
    result
}

fn to_pascal_case(s: &str) -> String {
    s.split('_')
        .map(|word| {
            let mut chars = word.chars();
            match chars.next() {
                None => String::new(),
                Some(first) => first.to_uppercase().collect::<String>() + chars.as_str(),
            }
        })
        .collect()
}
