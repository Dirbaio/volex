//! Go code generator for volex schemas.

use std::fmt::Write;

use crate::schema::*;

fn wire_type_to_go_const(wire_type: WireType) -> &'static str {
    match wire_type {
        WireType::Fixed8 => "__rt.WireFixed8",
        WireType::Varint => "__rt.WireVarint",
        WireType::Fixed32 => "__rt.WireFixed32",
        WireType::Fixed64 => "__rt.WireFixed64",
        WireType::Bytes => "__rt.WireBytes",
        WireType::Message => "__rt.WireMessage",
        WireType::Union => "__rt.WireUnion",
        WireType::Unit => "__rt.WireUnit",
    }
}

pub fn generate(schema: &Schema, package_name: &str) -> String {
    let generator = GoCodeGenerator::new(schema, package_name);
    generator.generate()
}

struct GoCodeGenerator<'a> {
    schema: &'a Schema,
    package_name: &'a str,
    output: String,
}

impl<'a> GoCodeGenerator<'a> {
    fn new(schema: &'a Schema, package_name: &'a str) -> Self {
        Self {
            schema,
            package_name,
            output: String::new(),
        }
    }

    fn generate(mut self) -> String {
        self.output.push_str("// Code generated by volex. DO NOT EDIT.\n\n");
        writeln!(self.output, "package {}\n", self.package_name).unwrap();

        // Check if we need encoding/json (for enums, unions, structs/messages with []uint8 fields)
        let needs_json = self.schema.items.iter().any(|item| match &item.node {
            Item::Enum(_) | Item::Union(_) => true,
            _ => false,
        });

        // Check if we need context (for services)
        let needs_context = self
            .schema
            .items
            .iter()
            .any(|item| matches!(&item.node, Item::Service(_)));

        self.output.push_str("import (\n");
        if needs_context {
            self.output.push_str("\t\"context\"\n");
        }
        if needs_json {
            self.output.push_str("\t\"encoding/json\"\n");
        }
        self.output.push_str("\t__rt \"github.com/volex/runtime\"\n");
        self.output.push_str(")\n\n");

        for item in &self.schema.items {
            match &item.node {
                Item::Struct(s) => self.gen_struct(s),
                Item::Message(m) => self.gen_message(m),
                Item::Enum(e) => self.gen_enum(e),
                Item::Union(u) => self.gen_union(u),
                Item::Service(s) => self.gen_service(s),
            }
            self.output.push('\n');
        }

        self.output
    }

    fn go_type(&self, ty: &Type) -> String {
        match ty {
            Type::Bool => "bool".to_string(),
            Type::U8 => "uint8".to_string(),
            Type::U16 => "uint16".to_string(),
            Type::U32 => "uint32".to_string(),
            Type::U64 => "uint64".to_string(),
            Type::I8 => "int8".to_string(),
            Type::I16 => "int16".to_string(),
            Type::I32 => "int32".to_string(),
            Type::I64 => "int64".to_string(),
            Type::F32 => "float32".to_string(),
            Type::F64 => "float64".to_string(),
            Type::String => "string".to_string(),
            Type::Array(inner) => format!("[]{}", self.go_type(&inner.node)),
            Type::Map(k, v) => format!("map[{}]{}", self.go_type(&k.node), self.go_type(&v.node)),
            Type::Named(name) => {
                // All named types (enums, structs, messages) are value types
                // Unions are interfaces which are reference types
                name.clone()
            }
        }
    }

    fn go_type_optional(&self, ty: &Type) -> String {
        // Optional types are always pointers
        format!("*{}", self.go_type(ty))
    }

    fn json_tag(&self, field_name: &str, ty: &Type) -> String {
        // Check if this is a []uint8 (byte array) which needs format:array
        if matches!(ty, Type::Array(inner) if matches!(&inner.node, Type::U8)) {
            format!("`json:\"{},format:array\"`", field_name)
        } else {
            format!("`json:\"{}\"`", field_name)
        }
    }

    fn gen_struct(&mut self, s: &Struct) {
        writeln!(self.output, "type {} struct {{", s.name.node).unwrap();

        for field in &s.fields {
            let ty = if field.optional {
                self.go_type_optional(&field.ty.node)
            } else {
                self.go_type(&field.ty.node)
            };
            // Don't use omitempty - we want to serialize null for optional fields
            writeln!(
                self.output,
                "\t{} {} {}",
                to_pascal_case(&field.name.node),
                ty,
                self.json_tag(&field.name.node, &field.ty.node)
            )
            .unwrap();
        }

        self.output.push_str("}\n\n");

        // Generate Encode method
        writeln!(self.output, "func (s *{}) Encode(buf *[]byte) {{", s.name.node).unwrap();

        // Handle optional fields - encode presence bits first
        let optional_fields: Vec<_> = s.fields.iter().filter(|f| f.optional).collect();
        if !optional_fields.is_empty() {
            self.output.push_str("\t// Encode presence bits\n");
            self.output.push_str("\tpresence := []bool{");
            for (i, field) in optional_fields.iter().enumerate() {
                if i > 0 {
                    self.output.push_str(", ");
                }
                write!(self.output, "s.{} != nil", to_pascal_case(&field.name.node)).unwrap();
            }
            self.output.push_str("}\n");
            self.output.push_str("\t__rt.EncodePresenceBits(presence, buf)\n\n");
        }

        // Encode each field
        for field in &s.fields {
            let field_name = to_pascal_case(&field.name.node);
            if field.optional {
                writeln!(self.output, "\tif s.{} != nil {{", field_name).unwrap();
                // For optional fields, we need to dereference the pointer
                // Use parentheses to avoid ambiguity with method calls
                self.encode_value(&format!("(*s.{})", field_name), &field.ty.node, 2);
                self.output.push_str("\t}\n");
            } else {
                self.encode_value(&format!("s.{}", field_name), &field.ty.node, 1);
            }
        }

        self.output.push_str("}\n\n");

        // Generate Decode method
        writeln!(
            self.output,
            "func Decode{}(buf *[]byte) ({}, error) {{",
            s.name.node, s.name.node
        )
        .unwrap();
        // Only declare err if we have fields to decode
        if !s.fields.is_empty() {
            writeln!(self.output, "\tvar err error").unwrap();
        }
        writeln!(self.output, "\tvar result {}", s.name.node).unwrap();

        // Handle optional fields - decode presence bits first
        if !optional_fields.is_empty() {
            writeln!(self.output, "\tvar presence []bool").unwrap();
            writeln!(
                self.output,
                "\tpresence, err = __rt.DecodePresenceBits({}, buf)",
                optional_fields.len()
            )
            .unwrap();
            writeln!(self.output, "\tif err != nil {{").unwrap();
            writeln!(self.output, "\t\treturn {}{{}}, err", s.name.node).unwrap();
            writeln!(self.output, "\t}}").unwrap();
            self.output.push('\n');
        }

        // Decode each field
        let mut presence_idx = 0;
        for field in &s.fields {
            let field_name = to_pascal_case(&field.name.node);
            if field.optional {
                writeln!(self.output, "\tif presence[{}] {{", presence_idx).unwrap();
                self.decode_value(&format!("result.{}", field_name), &field.ty.node, 2, true, &s.name.node);
                self.output.push_str("\t}\n");
                presence_idx += 1;
            } else {
                self.decode_value(
                    &format!("result.{}", field_name),
                    &field.ty.node,
                    1,
                    false,
                    &s.name.node,
                );
            }
        }

        self.output.push_str("\treturn result, nil\n");
        self.output.push_str("}\n");
    }

    fn gen_message(&mut self, m: &Message) {
        writeln!(self.output, "type {} struct {{", m.name.node).unwrap();

        for field in &m.fields {
            let ty = if field.optional {
                self.go_type_optional(&field.ty.node)
            } else {
                self.go_type(&field.ty.node)
            };
            // Don't use omitempty - we want to serialize null for optional fields
            writeln!(
                self.output,
                "\t{} {} {}",
                to_pascal_case(&field.name.node),
                ty,
                self.json_tag(&field.name.node, &field.ty.node)
            )
            .unwrap();
        }

        self.output.push_str("}\n\n");

        // Generate Encode method
        writeln!(self.output, "func (m *{}) Encode(buf *[]byte) {{", m.name.node).unwrap();

        // Sort fields by index for encoding in index order
        let mut sorted_fields: Vec<_> = m.fields.iter().collect();
        sorted_fields.sort_by_key(|f| f.index.node);

        for field in sorted_fields {
            let field_name = to_pascal_case(&field.name.node);
            let index = field.index.node;

            if field.optional {
                writeln!(self.output, "\tif m.{} != nil {{", field_name).unwrap();
                self.encode_tagged_field(index, &format!("(*m.{})", field_name), &field.ty.node, 2);
                self.output.push_str("\t}\n");
            } else {
                self.encode_tagged_field(index, &format!("m.{}", field_name), &field.ty.node, 1);
            }
        }

        self.output.push_str("\t__rt.EncodeMessageEnd(buf)\n");
        self.output.push_str("}\n\n");

        // Generate Decode method
        writeln!(
            self.output,
            "func Decode{}(buf *[]byte) ({}, error) {{",
            m.name.node, m.name.node
        )
        .unwrap();
        writeln!(self.output, "\tvar result {}", m.name.node).unwrap();

        self.output.push_str("\tfor {\n");
        self.output
            .push_str("\t\tindex, wireType, hasMore, err := __rt.DecodeTag(buf)\n");
        writeln!(self.output, "\t\tif err != nil {{").unwrap();
        writeln!(self.output, "\t\t\treturn {}{{}}, err", m.name.node).unwrap();
        writeln!(self.output, "\t\t}}").unwrap();
        self.output.push_str("\t\tif !hasMore {\n\t\t\tbreak\n\t\t}\n\n");
        self.output.push_str("\t\tswitch index {\n");

        for field in &m.fields {
            let field_name = to_pascal_case(&field.name.node);
            let index = field.index.node;
            writeln!(self.output, "\t\tcase {}:", index).unwrap();
            self.decode_tagged_field(
                &format!("result.{}", field_name),
                &field.ty.node,
                3,
                field.optional,
                &m.name.node,
            );
        }

        self.output.push_str("\t\tdefault:\n");
        self.output
            .push_str("\t\t\tif err := __rt.SkipByWireType(wireType, buf); err != nil {\n");
        writeln!(self.output, "\t\t\t\treturn {}{{}}, err", m.name.node).unwrap();
        self.output.push_str("\t\t\t}\n");
        self.output.push_str("\t\t}\n");
        self.output.push_str("\t}\n");
        self.output.push_str("\treturn result, nil\n");
        self.output.push_str("}\n");
    }

    fn gen_enum(&mut self, e: &Enum) {
        writeln!(self.output, "type {} uint32\n", e.name.node).unwrap();

        self.output.push_str("const (\n");
        for variant in &e.variants {
            writeln!(
                self.output,
                "\t{}{} {} = {}",
                e.name.node,
                to_pascal_case(&variant.name.node),
                e.name.node,
                variant.index.node
            )
            .unwrap();
        }
        self.output.push_str(")\n\n");

        // Generate Encode method
        writeln!(self.output, "func (e {}) Encode(buf *[]byte) {{", e.name.node).unwrap();
        self.output.push_str("\t__rt.EncodeU32(uint32(e), buf)\n");
        self.output.push_str("}\n\n");

        // Generate Decode method
        writeln!(
            self.output,
            "func Decode{}(buf *[]byte) ({}, error) {{",
            e.name.node, e.name.node
        )
        .unwrap();
        self.output.push_str("\tv, err := __rt.DecodeU32(buf)\n");
        self.output.push_str("\tif err != nil {\n\t\treturn 0, err\n\t}\n");
        self.output.push_str("\tswitch v {\n");

        for variant in &e.variants {
            writeln!(self.output, "\tcase {}:", variant.index.node).unwrap();
            writeln!(
                self.output,
                "\t\treturn {}{}, nil",
                e.name.node,
                to_pascal_case(&variant.name.node)
            )
            .unwrap();
        }

        self.output.push_str("\tdefault:\n");
        self.output.push_str("\t\treturn 0, __rt.ErrUnknownEnumVariant\n");
        self.output.push_str("\t}\n");
        self.output.push_str("}\n\n");

        // Generate MarshalJSON method
        writeln!(self.output, "func (e {}) MarshalJSON() ([]byte, error) {{", e.name.node).unwrap();
        self.output.push_str("\tswitch e {\n");
        for variant in &e.variants {
            writeln!(
                self.output,
                "\tcase {}{}:",
                e.name.node,
                to_pascal_case(&variant.name.node)
            )
            .unwrap();
            writeln!(self.output, "\t\treturn []byte(\"\\\"{}\\\"\"), nil", variant.name.node).unwrap();
        }
        self.output.push_str("\tdefault:\n");
        self.output.push_str("\t\treturn nil, __rt.ErrUnknownEnumVariant\n");
        self.output.push_str("\t}\n");
        self.output.push_str("}\n\n");

        // Generate UnmarshalJSON method
        writeln!(
            self.output,
            "func (e *{}) UnmarshalJSON(data []byte) error {{",
            e.name.node
        )
        .unwrap();
        self.output.push_str("\tvar s string\n");
        self.output
            .push_str("\tif err := json.Unmarshal(data, &s); err != nil {\n\t\treturn err\n\t}\n");
        self.output.push_str("\tswitch s {\n");
        for variant in &e.variants {
            writeln!(self.output, "\tcase \"{}\":", variant.name.node).unwrap();
            writeln!(
                self.output,
                "\t\t*e = {}{}",
                e.name.node,
                to_pascal_case(&variant.name.node)
            )
            .unwrap();
        }
        self.output.push_str("\tdefault:\n");
        self.output.push_str("\t\treturn __rt.ErrUnknownEnumVariant\n");
        self.output.push_str("\t}\n");
        self.output.push_str("\treturn nil\n");
        self.output.push_str("}\n");
    }

    fn gen_union(&mut self, u: &Union) {
        let union_name = &u.name.node;

        // Generate union struct with tag and value fields (private)
        writeln!(self.output, "type {} struct {{", union_name).unwrap();
        writeln!(self.output, "\ttag uint32").unwrap();
        writeln!(self.output, "\tvalue interface{{}}").unwrap();
        writeln!(self.output, "}}\n").unwrap();

        // Generate constructors for each variant
        for variant in &u.variants {
            let variant_method = to_pascal_case(&variant.name.node);
            let index = variant.index.node;

            if let Some(ref ty) = variant.ty {
                writeln!(
                    self.output,
                    "// New{}{} creates a {} with {} variant",
                    union_name, variant_method, union_name, variant.name.node
                )
                .unwrap();
                writeln!(
                    self.output,
                    "func New{}{}(value {}) {} {{",
                    union_name,
                    variant_method,
                    self.go_type(&ty.node),
                    union_name
                )
                .unwrap();
                writeln!(self.output, "\treturn {}{{{}, &value}}", union_name, index).unwrap();
                writeln!(self.output, "}}\n").unwrap();
            } else {
                writeln!(
                    self.output,
                    "// New{}{} creates a {} with {} variant",
                    union_name, variant_method, union_name, variant.name.node
                )
                .unwrap();
                writeln!(
                    self.output,
                    "func New{}{}() {} {{",
                    union_name, variant_method, union_name
                )
                .unwrap();
                writeln!(self.output, "\treturn {}{{{}, nil}}", union_name, index).unwrap();
                writeln!(self.output, "}}\n").unwrap();
            }
        }

        // Generate init method to handle zero-value case
        writeln!(
            self.output,
            "// init ensures the union has a valid tag (converts zero-value to first variant)"
        )
        .unwrap();
        writeln!(self.output, "func (v *{}) init() {{", union_name).unwrap();
        writeln!(self.output, "\tif v.tag == 0 {{").unwrap();

        // Find the first variant (lowest index)
        let first_variant = u.variants.iter().min_by_key(|v| v.index.node).unwrap();
        let first_index = first_variant.index.node;

        writeln!(self.output, "\t\tv.tag = {}", first_index).unwrap();
        if let Some(ref ty) = first_variant.ty {
            // Initialize with zero value of the type as a pointer
            writeln!(self.output, "\t\tvar zero {}", self.go_type(&ty.node)).unwrap();
            writeln!(self.output, "\t\tv.value = &zero").unwrap();
        } else {
            writeln!(self.output, "\t\tv.value = nil").unwrap();
        }
        writeln!(self.output, "\t}}").unwrap();
        writeln!(self.output, "}}\n").unwrap();

        // Generate getters for each variant
        for variant in &u.variants {
            let variant_method = to_pascal_case(&variant.name.node);
            let index = variant.index.node;

            if let Some(ref ty) = variant.ty {
                writeln!(
                    self.output,
                    "// {} returns the value if this union is a {} variant, otherwise returns nil",
                    variant_method, variant.name.node
                )
                .unwrap();
                writeln!(
                    self.output,
                    "func (v *{}) {}() *{} {{",
                    union_name,
                    variant_method,
                    self.go_type(&ty.node)
                )
                .unwrap();
                writeln!(self.output, "\tv.init()").unwrap();
                writeln!(self.output, "\tif v.tag == {} {{", index).unwrap();
                writeln!(self.output, "\t\treturn v.value.(*{})", self.go_type(&ty.node)).unwrap();
                writeln!(self.output, "\t}}").unwrap();
                writeln!(self.output, "\treturn nil").unwrap();
                writeln!(self.output, "}}\n").unwrap();
            } else {
                writeln!(
                    self.output,
                    "// Is{} returns true if this union is a {} variant",
                    variant_method, variant.name.node
                )
                .unwrap();
                writeln!(self.output, "func (v *{}) Is{}() bool {{", union_name, variant_method).unwrap();
                writeln!(self.output, "\tv.init()").unwrap();
                writeln!(self.output, "\treturn v.tag == {}", index).unwrap();
                writeln!(self.output, "}}\n").unwrap();
            }
        }

        // Generate Encode method
        writeln!(self.output, "// Encode encodes the union to the wire format").unwrap();
        writeln!(self.output, "func (v *{}) Encode(buf *[]byte) {{", union_name).unwrap();
        writeln!(self.output, "\tv.init()").unwrap();
        writeln!(self.output, "\tswitch v.tag {{").unwrap();

        for variant in &u.variants {
            let index = variant.index.node;
            writeln!(self.output, "\tcase {}:", index).unwrap();

            if let Some(ref ty) = variant.ty {
                writeln!(self.output, "\t\tvalue := *v.value.(*{})", self.go_type(&ty.node)).unwrap();
                self.encode_tagged_field(index, "value", &ty.node, 2);
            } else {
                writeln!(
                    self.output,
                    "\t\t__rt.EncodeTag({}, {}, buf)",
                    index,
                    wire_type_to_go_const(WireType::Unit)
                )
                .unwrap();
            }
        }

        writeln!(self.output, "\tdefault:").unwrap();
        writeln!(self.output, "\t\tpanic(\"invalid union tag\")").unwrap();
        writeln!(self.output, "\t}}").unwrap();
        writeln!(self.output, "}}\n").unwrap();

        // Generate Decode function
        writeln!(
            self.output,
            "// Decode{} decodes a {} from the wire format",
            union_name, union_name
        )
        .unwrap();
        writeln!(
            self.output,
            "func Decode{}(buf *[]byte) ({}, error) {{",
            union_name, union_name
        )
        .unwrap();
        writeln!(self.output, "\tindex, _, _, err := __rt.DecodeTag(buf)").unwrap();
        writeln!(self.output, "\tif err != nil {{").unwrap();
        writeln!(self.output, "\t\treturn {}{{}}, err", union_name).unwrap();
        writeln!(self.output, "\t}}").unwrap();
        writeln!(self.output, "\tswitch index {{").unwrap();

        for variant in &u.variants {
            let index = variant.index.node;
            writeln!(self.output, "\tcase {}:", index).unwrap();

            if let Some(ref ty) = variant.ty {
                writeln!(self.output, "\t\tvar value {}", self.go_type(&ty.node)).unwrap();
                self.decode_tagged_field("value", &ty.node, 2, false, union_name);

                // If the value is a union type, call init() on it through a pointer
                if let Type::Named(name) = &ty.node {
                    let is_union =
                        self.schema.items.iter().any(|item| {
                            item.node.name() == name && matches!(&item.node, crate::schema::Item::Union(_))
                        });
                    if is_union {
                        writeln!(self.output, "\t\t(&value).init()").unwrap();
                    }
                }

                writeln!(self.output, "\t\treturn {}{{{}, &value}}, nil", union_name, index).unwrap();
            } else {
                writeln!(self.output, "\t\treturn {}{{{}, nil}}, nil", union_name, index).unwrap();
            }
        }

        writeln!(self.output, "\tdefault:").unwrap();
        writeln!(
            self.output,
            "\t\treturn {}{{}}, __rt.ErrUnknownUnionVariant",
            union_name
        )
        .unwrap();
        writeln!(self.output, "\t}}").unwrap();
        writeln!(self.output, "}}\n").unwrap();

        // Generate MarshalJSON
        writeln!(self.output, "// MarshalJSON implements json.Marshaler").unwrap();
        writeln!(self.output, "func (v *{}) MarshalJSON() ([]byte, error) {{", union_name).unwrap();
        writeln!(self.output, "\tv.init()").unwrap();
        writeln!(self.output, "\tswitch v.tag {{").unwrap();

        for variant in &u.variants {
            let index = variant.index.node;
            writeln!(self.output, "\tcase {}:", index).unwrap();

            if let Some(ref ty) = variant.ty {
                // Check if this is []uint8 which needs special handling to avoid base64 encoding
                let is_byte_array = matches!(&ty.node, Type::Array(inner) if matches!(&inner.node, Type::U8));

                if is_byte_array {
                    // For []uint8, we need to convert to []interface{} to get JSON array instead of base64
                    writeln!(self.output, "\t\tval := *v.value.(*[]uint8)").unwrap();
                    writeln!(self.output, "\t\tarr := make([]interface{{}}, len(val))").unwrap();
                    writeln!(self.output, "\t\tfor i, b := range val {{").unwrap();
                    writeln!(self.output, "\t\t\tarr[i] = b").unwrap();
                    writeln!(self.output, "\t\t}}").unwrap();
                    writeln!(self.output, "\t\tm := map[string]interface{{}}{{").unwrap();
                    writeln!(self.output, "\t\t\t\"$tag\": \"{}\",", variant.name.node).unwrap();
                    writeln!(self.output, "\t\t\t\"$value\": arr,").unwrap();
                    writeln!(self.output, "\t\t}}").unwrap();
                    writeln!(self.output, "\t\treturn json.Marshal(m)").unwrap();
                } else {
                    // If the value is a union type, take its address for JSON marshaling
                    let is_union = if let Type::Named(name) = &ty.node {
                        self.schema
                            .items
                            .iter()
                            .any(|item| item.node.name() == name && matches!(&item.node, crate::schema::Item::Union(_)))
                    } else {
                        false
                    };

                    if is_union {
                        writeln!(self.output, "\t\tval := v.value.(*{})", self.go_type(&ty.node)).unwrap();
                        writeln!(self.output, "\t\tm := map[string]interface{{}}{{").unwrap();
                        writeln!(self.output, "\t\t\t\"$tag\": \"{}\",", variant.name.node).unwrap();
                        writeln!(self.output, "\t\t\t\"$value\": val,").unwrap();
                        writeln!(self.output, "\t\t}}").unwrap();
                        writeln!(self.output, "\t\treturn json.Marshal(m)").unwrap();
                    } else {
                        writeln!(self.output, "\t\tm := map[string]interface{{}}{{").unwrap();
                        writeln!(self.output, "\t\t\t\"$tag\": \"{}\",", variant.name.node).unwrap();
                        writeln!(self.output, "\t\t\t\"$value\": *v.value.(*{}),", self.go_type(&ty.node)).unwrap();
                        writeln!(self.output, "\t\t}}").unwrap();
                        writeln!(self.output, "\t\treturn json.Marshal(m)").unwrap();
                    }
                }
            } else {
                writeln!(self.output, "\t\tm := map[string]interface{{}}{{").unwrap();
                writeln!(self.output, "\t\t\t\"$tag\": \"{}\",", variant.name.node).unwrap();
                writeln!(self.output, "\t\t}}").unwrap();
                writeln!(self.output, "\t\treturn json.Marshal(m)").unwrap();
            }
        }

        writeln!(self.output, "\tdefault:").unwrap();
        writeln!(self.output, "\t\tpanic(\"invalid union tag\")").unwrap();
        writeln!(self.output, "\t}}").unwrap();
        writeln!(self.output, "}}\n").unwrap();

        // Generate UnmarshalJSON
        writeln!(self.output, "// UnmarshalJSON implements json.Unmarshaler").unwrap();
        writeln!(
            self.output,
            "func (v *{}) UnmarshalJSON(data []byte) error {{",
            union_name
        )
        .unwrap();
        writeln!(self.output, "\t// Try unit variant (just a string)").unwrap();
        writeln!(self.output, "\tvar tag string").unwrap();
        writeln!(self.output, "\tif err := json.Unmarshal(data, &tag); err == nil {{").unwrap();
        writeln!(self.output, "\t\tswitch tag {{").unwrap();

        for variant in &u.variants {
            if variant.ty.is_none() {
                let index = variant.index.node;
                writeln!(self.output, "\t\tcase \"{}\":", variant.name.node).unwrap();
                writeln!(self.output, "\t\t\tv.tag = {}", index).unwrap();
                writeln!(self.output, "\t\t\tv.value = nil").unwrap();
                writeln!(self.output, "\t\t\treturn nil").unwrap();
            }
        }

        writeln!(self.output, "\t\t}}").unwrap();
        writeln!(self.output, "\t}}").unwrap();
        writeln!(self.output, "\t// Try tagged variant").unwrap();
        writeln!(self.output, "\tvar wrapper struct {{").unwrap();
        writeln!(self.output, "\t\tTag string `json:\"$tag\"`").unwrap();
        writeln!(self.output, "\t\tValue json.RawMessage `json:\"$value\"`").unwrap();
        writeln!(self.output, "\t}}").unwrap();
        writeln!(self.output, "\tif err := json.Unmarshal(data, &wrapper); err != nil {{").unwrap();
        writeln!(self.output, "\t\treturn err").unwrap();
        writeln!(self.output, "\t}}").unwrap();
        writeln!(self.output, "\tswitch wrapper.Tag {{").unwrap();

        for variant in &u.variants {
            let index = variant.index.node;
            writeln!(self.output, "\tcase \"{}\":", variant.name.node).unwrap();

            if let Some(ref ty) = variant.ty {
                writeln!(self.output, "\t\tvar value {}", self.go_type(&ty.node)).unwrap();
                writeln!(
                    self.output,
                    "\t\tif err := json.Unmarshal(wrapper.Value, &value); err != nil {{"
                )
                .unwrap();
                writeln!(self.output, "\t\t\treturn err").unwrap();
                writeln!(self.output, "\t\t}}").unwrap();

                // If the value is a union type (Named type that's a union), call init() on it through a pointer
                if let Type::Named(name) = &ty.node {
                    // Check if this is a union by looking it up in the schema
                    let is_union =
                        self.schema.items.iter().any(|item| {
                            item.node.name() == name && matches!(&item.node, crate::schema::Item::Union(_))
                        });
                    if is_union {
                        writeln!(self.output, "\t\t(&value).init()").unwrap();
                    }
                }

                writeln!(self.output, "\t\tv.tag = {}", index).unwrap();
                writeln!(self.output, "\t\tv.value = &value").unwrap();
                writeln!(self.output, "\t\treturn nil").unwrap();
            } else {
                writeln!(self.output, "\t\tv.tag = {}", index).unwrap();
                writeln!(self.output, "\t\tv.value = nil").unwrap();
                writeln!(self.output, "\t\treturn nil").unwrap();
            }
        }

        writeln!(self.output, "\tdefault:").unwrap();
        writeln!(self.output, "\t\treturn __rt.ErrUnknownUnionVariant").unwrap();
        writeln!(self.output, "\t}}").unwrap();
        writeln!(self.output, "}}\n").unwrap();
    }

    fn encode_value(&mut self, value: &str, ty: &Type, indent: usize) {
        let tabs = "\t".repeat(indent);
        match ty {
            Type::Bool => writeln!(self.output, "{}__rt.EncodeBool({}, buf)", tabs, value).unwrap(),
            Type::U8 => writeln!(self.output, "{}__rt.EncodeU8({}, buf)", tabs, value).unwrap(),
            Type::U16 => writeln!(self.output, "{}__rt.EncodeU16({}, buf)", tabs, value).unwrap(),
            Type::U32 => writeln!(self.output, "{}__rt.EncodeU32({}, buf)", tabs, value).unwrap(),
            Type::U64 => writeln!(self.output, "{}__rt.EncodeU64({}, buf)", tabs, value).unwrap(),
            Type::I8 => writeln!(self.output, "{}__rt.EncodeI8({}, buf)", tabs, value).unwrap(),
            Type::I16 => writeln!(self.output, "{}__rt.EncodeI16({}, buf)", tabs, value).unwrap(),
            Type::I32 => writeln!(self.output, "{}__rt.EncodeI32({}, buf)", tabs, value).unwrap(),
            Type::I64 => writeln!(self.output, "{}__rt.EncodeI64({}, buf)", tabs, value).unwrap(),
            Type::F32 => writeln!(self.output, "{}__rt.EncodeF32({}, buf)", tabs, value).unwrap(),
            Type::F64 => writeln!(self.output, "{}__rt.EncodeF64({}, buf)", tabs, value).unwrap(),
            Type::String => writeln!(self.output, "{}__rt.EncodeString({}, buf)", tabs, value).unwrap(),
            Type::Array(inner) => {
                writeln!(self.output, "{}__rt.EncodeLEB128(uint64(len({})), buf)", tabs, value).unwrap();
                writeln!(self.output, "{}for _, item := range {} {{", tabs, value).unwrap();
                self.encode_value("item", &inner.node, indent + 1);
                writeln!(self.output, "{}}}", tabs).unwrap();
            }
            Type::Map(k, v) => {
                writeln!(self.output, "{}__rt.EncodeLEB128(uint64(len({})), buf)", tabs, value).unwrap();
                writeln!(self.output, "{}for k, v := range {} {{", tabs, value).unwrap();
                self.encode_value("k", &k.node, indent + 1);
                self.encode_value("v", &v.node, indent + 1);
                writeln!(self.output, "{}}}", tabs).unwrap();
            }
            Type::Named(_) => {
                writeln!(self.output, "{}{}.Encode(buf)", tabs, value).unwrap();
            }
        }
    }

    fn decode_value(&mut self, target: &str, ty: &Type, indent: usize, optional: bool, parent_type: &str) {
        let tabs = "\t".repeat(indent);

        // Arrays and maps need custom decoding logic
        match ty {
            Type::Array(inner) => {
                self.decode_array(target, &inner.node, indent, optional, parent_type);
                return;
            }
            Type::Map(k, v) => {
                self.decode_map(target, &k.node, &v.node, indent, optional, parent_type);
                return;
            }
            _ => {}
        }

        let (decode_call, _err_check) = self.decode_call(ty);

        if optional {
            writeln!(self.output, "{}var v {}", tabs, self.go_type(ty)).unwrap();
            writeln!(self.output, "{}v, err = {}", tabs, decode_call).unwrap();
            writeln!(self.output, "{}if err != nil {{", tabs).unwrap();
            writeln!(self.output, "{}\treturn {}{{}}, err", tabs, parent_type).unwrap();
            writeln!(self.output, "{}}}", tabs).unwrap();
            writeln!(self.output, "{}{} = &v", tabs, target).unwrap();
        } else {
            writeln!(self.output, "{}{}, err = {}", tabs, target, decode_call).unwrap();
            writeln!(self.output, "{}if err != nil {{", tabs).unwrap();
            writeln!(self.output, "{}\treturn {}{{}}, err", tabs, parent_type).unwrap();
            writeln!(self.output, "{}}}", tabs).unwrap();
        }
    }

    fn decode_array(&mut self, target: &str, elem_ty: &Type, indent: usize, optional: bool, parent_type: &str) {
        let tabs = "\t".repeat(indent);
        let elem_go_type = self.go_type(elem_ty);

        // Use indent to create unique variable names to avoid shadowing in nested arrays
        let count_var = format!("count{}", indent);
        let idx_var = format!("i{}", indent);
        let arr_var = if optional {
            format!("arr{}", indent)
        } else {
            target.to_string()
        };

        // Decode array length
        writeln!(self.output, "{}{}, err := __rt.DecodeLEB128(buf)", tabs, count_var).unwrap();
        writeln!(self.output, "{}if err != nil {{", tabs).unwrap();
        writeln!(self.output, "{}\treturn {}{{}}, err", tabs, parent_type).unwrap();
        writeln!(self.output, "{}}}", tabs).unwrap();

        if optional {
            writeln!(
                self.output,
                "{}{} := make([]{}, {})",
                tabs, arr_var, elem_go_type, count_var
            )
            .unwrap();
        } else {
            writeln!(
                self.output,
                "{}{} = make([]{}, {})",
                tabs, target, elem_go_type, count_var
            )
            .unwrap();
        }

        writeln!(
            self.output,
            "{}for {} := uint64(0); {} < {}; {}++ {{",
            tabs, idx_var, idx_var, count_var, idx_var
        )
        .unwrap();
        let item_target = format!("{}[{}]", arr_var, idx_var);
        self.decode_value_inline(&item_target, elem_ty, indent + 1, parent_type);
        writeln!(self.output, "{}}}", tabs).unwrap();

        if optional {
            writeln!(self.output, "{}{} = &{}", tabs, target, arr_var).unwrap();
        }
    }

    fn decode_map(
        &mut self,
        target: &str,
        key_ty: &Type,
        val_ty: &Type,
        indent: usize,
        optional: bool,
        parent_type: &str,
    ) {
        let tabs = "\t".repeat(indent);
        let key_go_type = self.go_type(key_ty);
        let val_go_type = self.go_type(val_ty);

        // Use indent to create unique variable names to avoid shadowing in nested maps
        let key_var = format!("k{}", indent);
        let val_var = format!("v{}", indent);
        let count_var = format!("count{}", indent);
        let map_var = if optional {
            format!("m{}", indent)
        } else {
            target.to_string()
        };

        // Decode map length
        writeln!(self.output, "{}{}, err := __rt.DecodeLEB128(buf)", tabs, count_var).unwrap();
        writeln!(self.output, "{}if err != nil {{", tabs).unwrap();
        writeln!(self.output, "{}\treturn {}{{}}, err", tabs, parent_type).unwrap();
        writeln!(self.output, "{}}}", tabs).unwrap();

        if optional {
            writeln!(
                self.output,
                "{}{} := make(map[{}]{}, {})",
                tabs, map_var, key_go_type, val_go_type, count_var
            )
            .unwrap();
        } else {
            writeln!(
                self.output,
                "{}{} = make(map[{}]{}, {})",
                tabs, target, key_go_type, val_go_type, count_var
            )
            .unwrap();
        }

        writeln!(
            self.output,
            "{}for i{} := uint64(0); i{} < {}; i{}++ {{",
            tabs, indent, indent, count_var, indent
        )
        .unwrap();
        writeln!(self.output, "{}\tvar {} {}", tabs, key_var, key_go_type).unwrap();
        writeln!(self.output, "{}\tvar {} {}", tabs, val_var, val_go_type).unwrap();
        self.decode_value_inline(&key_var, key_ty, indent + 1, parent_type);
        self.decode_value_inline(&val_var, val_ty, indent + 1, parent_type);
        writeln!(self.output, "{}\t{}[{}] = {}", tabs, map_var, key_var, val_var).unwrap();
        writeln!(self.output, "{}}}", tabs).unwrap();

        if optional {
            writeln!(self.output, "{}{} = &{}", tabs, target, map_var).unwrap();
        }
    }

    fn decode_value_inline(&mut self, target: &str, ty: &Type, indent: usize, parent_type: &str) {
        // Arrays and maps need specialized decoding
        match ty {
            Type::Array(inner) => {
                self.decode_array(target, &inner.node, indent, false, parent_type);
                return;
            }
            Type::Map(k, v) => {
                self.decode_map(target, &k.node, &v.node, indent, false, parent_type);
                return;
            }
            _ => {}
        }

        let tabs = "\t".repeat(indent);
        let (decode_call, _) = self.decode_call(ty);
        writeln!(self.output, "{}{}, err = {}", tabs, target, decode_call).unwrap();
        writeln!(self.output, "{}if err != nil {{", tabs).unwrap();
        writeln!(self.output, "{}\treturn {}{{}}, err", tabs, parent_type).unwrap();
        writeln!(self.output, "{}}}", tabs).unwrap();
    }

    fn decode_call(&self, ty: &Type) -> (String, bool) {
        match ty {
            Type::Bool => ("__rt.DecodeBool(buf)".to_string(), true),
            Type::U8 => ("__rt.DecodeU8(buf)".to_string(), true),
            Type::U16 => ("__rt.DecodeU16(buf)".to_string(), true),
            Type::U32 => ("__rt.DecodeU32(buf)".to_string(), true),
            Type::U64 => ("__rt.DecodeU64(buf)".to_string(), true),
            Type::I8 => ("__rt.DecodeI8(buf)".to_string(), true),
            Type::I16 => ("__rt.DecodeI16(buf)".to_string(), true),
            Type::I32 => ("__rt.DecodeI32(buf)".to_string(), true),
            Type::I64 => ("__rt.DecodeI64(buf)".to_string(), true),
            Type::F32 => ("__rt.DecodeF32(buf)".to_string(), true),
            Type::F64 => ("__rt.DecodeF64(buf)".to_string(), true),
            Type::String => ("__rt.DecodeString(buf)".to_string(), true),
            Type::Array(_) => ("nil, nil".to_string(), true), // TODO: implement array decode
            Type::Map(_, _) => ("nil, nil".to_string(), true), // TODO: implement map decode
            Type::Named(name) => (format!("Decode{}(buf)", name), true),
        }
    }

    fn encode_tagged_field(&mut self, index: u32, value: &str, ty: &Type, indent: usize) {
        let tabs = "\t".repeat(indent);
        let wire_type = self.wire_type(ty);
        writeln!(self.output, "{}__rt.EncodeTag({}, {}, buf)", tabs, index, wire_type).unwrap();

        if wire_type == "__rt.WireBytes" {
            // For length-delimited fields, we need to encode to a temp buffer,
            // then write the length, then the buffer
            writeln!(self.output, "{}{{", tabs).unwrap();
            writeln!(self.output, "{}\tlengthBuf := []byte{{}}", tabs).unwrap();
            writeln!(self.output, "{}\ttmpBuf := &lengthBuf", tabs).unwrap();
            self.encode_value_to_buf(value, ty, indent + 1, "tmpBuf", true);
            writeln!(self.output, "{}\t__rt.EncodeLEB128(uint64(len(lengthBuf)), buf)", tabs).unwrap();
            writeln!(self.output, "{}\t*buf = append(*buf, lengthBuf...)", tabs).unwrap();
            writeln!(self.output, "{}}}", tabs).unwrap();
        } else {
            self.encode_value(value, ty, indent);
        }
    }

    fn encode_value_to_buf(&mut self, value: &str, ty: &Type, indent: usize, buf_var: &str, in_bytes_field: bool) {
        let tabs = "\t".repeat(indent);
        match ty {
            Type::Bool => writeln!(self.output, "{}__rt.EncodeBool({}, {})", tabs, value, buf_var).unwrap(),
            Type::U8 => writeln!(self.output, "{}__rt.EncodeU8({}, {})", tabs, value, buf_var).unwrap(),
            Type::U16 => writeln!(self.output, "{}__rt.EncodeU16({}, {})", tabs, value, buf_var).unwrap(),
            Type::U32 => writeln!(self.output, "{}__rt.EncodeU32({}, {})", tabs, value, buf_var).unwrap(),
            Type::U64 => writeln!(self.output, "{}__rt.EncodeU64({}, {})", tabs, value, buf_var).unwrap(),
            Type::I8 => writeln!(self.output, "{}__rt.EncodeI8({}, {})", tabs, value, buf_var).unwrap(),
            Type::I16 => writeln!(self.output, "{}__rt.EncodeI16({}, {})", tabs, value, buf_var).unwrap(),
            Type::I32 => writeln!(self.output, "{}__rt.EncodeI32({}, {})", tabs, value, buf_var).unwrap(),
            Type::I64 => writeln!(self.output, "{}__rt.EncodeI64({}, {})", tabs, value, buf_var).unwrap(),
            Type::F32 => writeln!(self.output, "{}__rt.EncodeF32({}, {})", tabs, value, buf_var).unwrap(),
            Type::F64 => writeln!(self.output, "{}__rt.EncodeF64({}, {})", tabs, value, buf_var).unwrap(),
            Type::String => {
                if in_bytes_field {
                    // String is a direct BYTES field - outer length already encoded, just append raw bytes
                    writeln!(self.output, "{}*{} = append(*{}, {}...)", tabs, buf_var, buf_var, value).unwrap();
                } else {
                    // String is nested (e.g., in array) - needs its own length prefix
                    writeln!(self.output, "{}__rt.EncodeString({}, {})", tabs, value, buf_var).unwrap();
                }
            }
            Type::Array(inner) => {
                // Arrays in BYTES fields: only skip count if at top level AND elements are fixed-size.
                // Nested arrays always need a count prefix.
                let skip_count = in_bytes_field && self.schema.fixed_size(&inner.node).is_some();
                if skip_count {
                    // Fixed-size elements at top level: no count prefix
                    writeln!(self.output, "{}for _, item := range {} {{", tabs, value).unwrap();
                    self.encode_value_to_buf("item", &inner.node, indent + 1, buf_var, false);
                    writeln!(self.output, "{}}}", tabs).unwrap();
                } else {
                    // Variable-size elements or nested: include count prefix
                    writeln!(
                        self.output,
                        "{}__rt.EncodeLEB128(uint64(len({})), {})",
                        tabs, value, buf_var
                    )
                    .unwrap();
                    writeln!(self.output, "{}for _, item := range {} {{", tabs, value).unwrap();
                    self.encode_value_to_buf("item", &inner.node, indent + 1, buf_var, false);
                    writeln!(self.output, "{}}}", tabs).unwrap();
                }
            }
            Type::Map(k, v) => {
                // Maps in BYTES fields: only skip count if at top level AND entries are fixed-size.
                // Nested maps always need a count prefix.
                let key_fixed = self.schema.fixed_size(&k.node).is_some();
                let val_fixed = self.schema.fixed_size(&v.node).is_some();
                let skip_count = in_bytes_field && key_fixed && val_fixed;
                if skip_count {
                    // Fixed-size entries at top level: no count prefix
                    writeln!(self.output, "{}for k, v := range {} {{", tabs, value).unwrap();
                    self.encode_value_to_buf("k", &k.node, indent + 1, buf_var, false);
                    self.encode_value_to_buf("v", &v.node, indent + 1, buf_var, false);
                    writeln!(self.output, "{}}}", tabs).unwrap();
                } else {
                    // Variable-size entries or nested: include count prefix
                    writeln!(
                        self.output,
                        "{}__rt.EncodeLEB128(uint64(len({})), {})",
                        tabs, value, buf_var
                    )
                    .unwrap();
                    writeln!(self.output, "{}for k, v := range {} {{", tabs, value).unwrap();
                    self.encode_value_to_buf("k", &k.node, indent + 1, buf_var, false);
                    self.encode_value_to_buf("v", &v.node, indent + 1, buf_var, false);
                    writeln!(self.output, "{}}}", tabs).unwrap();
                }
            }
            Type::Named(_) => {
                writeln!(self.output, "{}{}.Encode({})", tabs, value, buf_var).unwrap();
            }
        }
    }

    fn decode_tagged_field(&mut self, target: &str, ty: &Type, indent: usize, optional: bool, parent_type: &str) {
        let tabs = "\t".repeat(indent);
        let wire_type = self.wire_type(ty);

        if wire_type == "__rt.WireBytes" {
            // For length-delimited fields, first decode the length
            writeln!(self.output, "{}length, err := __rt.DecodeLEB128(buf)", tabs).unwrap();
            writeln!(self.output, "{}if err != nil {{", tabs).unwrap();
            writeln!(self.output, "{}\treturn {}{{}}, err", tabs, parent_type).unwrap();
            writeln!(self.output, "{}}}", tabs).unwrap();

            // Special handling for strings, arrays, and maps in BYTES fields
            match ty {
                Type::String => {
                    // Strings in BYTES fields: no inner length prefix, just read 'length' bytes
                    // Bounds checking is implicit in the slice operation - Go will panic if out of bounds
                    // The runtime's error handling will catch this
                    if optional {
                        writeln!(self.output, "{}s := string((*buf)[:length])", tabs).unwrap();
                        writeln!(self.output, "{}{} = &s", tabs, target).unwrap();
                    } else {
                        writeln!(self.output, "{}{} = string((*buf)[:length])", tabs, target).unwrap();
                    }
                    writeln!(self.output, "{}*buf = (*buf)[length:]", tabs).unwrap();
                    return; // String was handled, skip normal decode
                }
                Type::Array(inner) => {
                    self.decode_array_from_bytes(target, &inner.node, indent, optional, parent_type, "length");
                    return; // Array was handled, skip normal decode
                }
                Type::Map(k, v) => {
                    self.decode_map_from_bytes(target, &k.node, &v.node, indent, optional, parent_type, "length");
                    return; // Map was handled, skip normal decode
                }
                _ => {}
            }

            // For structs/messages/named types, mark length as used and continue with normal decode
            writeln!(
                self.output,
                "{}_ = length // Bounds checking done by individual field decoders",
                tabs
            )
            .unwrap();
        }

        self.decode_value(target, ty, indent, optional, parent_type);
    }

    fn decode_array_from_bytes(
        &mut self,
        target: &str,
        elem_ty: &Type,
        indent: usize,
        optional: bool,
        parent_type: &str,
        length_var: &str,
    ) {
        let tabs = "\t".repeat(indent);
        let elem_go_type = self.go_type(elem_ty);

        // Use indent to create unique variable names to avoid shadowing in nested arrays
        let count_var = format!("count{}", indent);
        let idx_var = format!("i{}", indent);
        let arr_var = if optional {
            format!("arr{}", indent)
        } else {
            target.to_string()
        };

        if let Some(elem_size) = self.schema.fixed_size(elem_ty) {
            // Fixed-size elements: no count prefix, infer count from length / element_size
            writeln!(self.output, "{}{} := {} / {}", tabs, count_var, length_var, elem_size).unwrap();
            if optional {
                writeln!(
                    self.output,
                    "{}{} := make([]{}, {})",
                    tabs, arr_var, elem_go_type, count_var
                )
                .unwrap();
            } else {
                writeln!(
                    self.output,
                    "{}{} = make([]{}, {})",
                    tabs, target, elem_go_type, count_var
                )
                .unwrap();
            }
            writeln!(
                self.output,
                "{}for {} := uint64(0); {} < {}; {}++ {{",
                tabs, idx_var, idx_var, count_var, idx_var
            )
            .unwrap();
            let item_target = format!("{}[{}]", arr_var, idx_var);
            self.decode_value_inline(&item_target, elem_ty, indent + 1, parent_type);
            writeln!(self.output, "{}}}", tabs).unwrap();
            if optional {
                writeln!(self.output, "{}{} = &{}", tabs, target, arr_var).unwrap();
            }
        } else {
            // Variable-size elements: read count prefix, then elements
            writeln!(self.output, "{}_ = {} // Outer BYTES length", tabs, length_var).unwrap();
            writeln!(self.output, "{}{}, err := __rt.DecodeLEB128(buf)", tabs, count_var).unwrap();
            writeln!(self.output, "{}if err != nil {{", tabs).unwrap();
            writeln!(self.output, "{}\treturn {}{{}}, err", tabs, parent_type).unwrap();
            writeln!(self.output, "{}}}", tabs).unwrap();
            if optional {
                writeln!(
                    self.output,
                    "{}{} := make([]{}, {})",
                    tabs, arr_var, elem_go_type, count_var
                )
                .unwrap();
            } else {
                writeln!(
                    self.output,
                    "{}{} = make([]{}, {})",
                    tabs, target, elem_go_type, count_var
                )
                .unwrap();
            }
            writeln!(
                self.output,
                "{}for {} := uint64(0); {} < {}; {}++ {{",
                tabs, idx_var, idx_var, count_var, idx_var
            )
            .unwrap();
            let item_target = format!("{}[{}]", arr_var, idx_var);
            self.decode_value_inline(&item_target, elem_ty, indent + 1, parent_type);
            writeln!(self.output, "{}}}", tabs).unwrap();
            if optional {
                writeln!(self.output, "{}{} = &{}", tabs, target, arr_var).unwrap();
            }
        }
    }

    fn decode_map_from_bytes(
        &mut self,
        target: &str,
        key_ty: &Type,
        val_ty: &Type,
        indent: usize,
        optional: bool,
        parent_type: &str,
        length_var: &str,
    ) {
        let tabs = "\t".repeat(indent);
        let key_go_type = self.go_type(key_ty);
        let val_go_type = self.go_type(val_ty);

        // Use indent to create unique variable names to avoid shadowing in nested maps
        let key_var = format!("k{}", indent);
        let val_var = format!("v{}", indent);
        let count_var = format!("count{}", indent);
        let idx_var = format!("i{}", indent);
        let map_var = if optional {
            format!("m{}", indent)
        } else {
            target.to_string()
        };

        let key_fixed = {
            let this = &self;
            this.schema.fixed_size(key_ty).is_some()
        };
        let val_fixed = {
            let this = &self;
            this.schema.fixed_size(val_ty).is_some()
        };

        if key_fixed && val_fixed {
            // Fixed-size entries: no count prefix, infer count from length
            let key_size = match key_ty {
                Type::Bool | Type::U8 | Type::I8 => 1,
                Type::F32 => 4,
                Type::F64 => 8,
                _ => panic!("Unexpected fixed-size type"),
            };
            let val_size = match val_ty {
                Type::Bool | Type::U8 | Type::I8 => 1,
                Type::F32 => 4,
                Type::F64 => 8,
                _ => panic!("Unexpected fixed-size type"),
            };
            let entry_size = key_size + val_size;
            writeln!(self.output, "{}{} := {} / {}", tabs, count_var, length_var, entry_size).unwrap();
            if optional {
                writeln!(
                    self.output,
                    "{}{} := make(map[{}]{}, {})",
                    tabs, map_var, key_go_type, val_go_type, count_var
                )
                .unwrap();
            } else {
                writeln!(
                    self.output,
                    "{}{} = make(map[{}]{}, {})",
                    tabs, target, key_go_type, val_go_type, count_var
                )
                .unwrap();
            }
            writeln!(
                self.output,
                "{}for {} := uint64(0); {} < {}; {}++ {{",
                tabs, idx_var, idx_var, count_var, idx_var
            )
            .unwrap();
            writeln!(self.output, "{}\tvar {} {}", tabs, key_var, key_go_type).unwrap();
            writeln!(self.output, "{}\tvar {} {}", tabs, val_var, val_go_type).unwrap();
            self.decode_value_inline(&key_var, key_ty, indent + 1, parent_type);
            self.decode_value_inline(&val_var, val_ty, indent + 1, parent_type);
            writeln!(self.output, "{}\t{}[{}] = {}", tabs, map_var, key_var, val_var).unwrap();
            writeln!(self.output, "{}}}", tabs).unwrap();
            if optional {
                writeln!(self.output, "{}{} = &{}", tabs, target, map_var).unwrap();
            }
        } else {
            // Variable-size entries: read count prefix, then entries
            writeln!(self.output, "{}_ = {} // Outer BYTES length", tabs, length_var).unwrap();
            writeln!(self.output, "{}{}, err := __rt.DecodeLEB128(buf)", tabs, count_var).unwrap();
            writeln!(self.output, "{}if err != nil {{", tabs).unwrap();
            writeln!(self.output, "{}\treturn {}{{}}, err", tabs, parent_type).unwrap();
            writeln!(self.output, "{}}}", tabs).unwrap();
            if optional {
                writeln!(
                    self.output,
                    "{}{} := make(map[{}]{}, {})",
                    tabs, map_var, key_go_type, val_go_type, count_var
                )
                .unwrap();
            } else {
                writeln!(
                    self.output,
                    "{}{} = make(map[{}]{}, {})",
                    tabs, target, key_go_type, val_go_type, count_var
                )
                .unwrap();
            }
            writeln!(
                self.output,
                "{}for {} := uint64(0); {} < {}; {}++ {{",
                tabs, idx_var, idx_var, count_var, idx_var
            )
            .unwrap();
            writeln!(self.output, "{}\tvar {} {}", tabs, key_var, key_go_type).unwrap();
            writeln!(self.output, "{}\tvar {} {}", tabs, val_var, val_go_type).unwrap();
            self.decode_value_inline(&key_var, key_ty, indent + 1, parent_type);
            self.decode_value_inline(&val_var, val_ty, indent + 1, parent_type);
            writeln!(self.output, "{}\t{}[{}] = {}", tabs, map_var, key_var, val_var).unwrap();
            writeln!(self.output, "{}}}", tabs).unwrap();
            if optional {
                writeln!(self.output, "{}{} = &{}", tabs, target, map_var).unwrap();
            }
        }
    }

    fn wire_type(&self, ty: &Type) -> &'static str {
        match self.schema.wire_type(ty) {
            crate::schema::WireType::Fixed8 => "__rt.WireFixed8",
            crate::schema::WireType::Varint => "__rt.WireVarint",
            crate::schema::WireType::Fixed32 => "__rt.WireFixed32",
            crate::schema::WireType::Fixed64 => "__rt.WireFixed64",
            crate::schema::WireType::Bytes => "__rt.WireBytes",
            crate::schema::WireType::Message => "__rt.WireMessage",
            crate::schema::WireType::Union => "__rt.WireUnion",
            crate::schema::WireType::Unit => "__rt.WireUnit",
        }
    }

    fn gen_service(&mut self, s: &Service) {
        let service_name = &s.name.node;

        // Generate the service interface
        writeln!(
            self.output,
            "// {} is the interface for the {} service.",
            service_name, service_name
        )
        .unwrap();
        writeln!(self.output, "type {} interface {{", service_name).unwrap();
        for method in &s.methods {
            let method_name = to_pascal_case(&method.name.node);
            let request_type = self.go_type(&method.request.node);
            match &method.response.node {
                ServiceResponse::Unary(resp_ty) => {
                    let response_type = self.go_type(resp_ty);
                    writeln!(
                        self.output,
                        "\t{}(ctx context.Context, req {}) ({}, error)",
                        method_name, request_type, response_type
                    )
                    .unwrap();
                }
                ServiceResponse::Stream(_) => {
                    writeln!(
                        self.output,
                        "\t{}(ctx context.Context, req {}, stream {}{}Stream) error",
                        method_name, request_type, service_name, method_name
                    )
                    .unwrap();
                }
            }
        }
        writeln!(self.output, "}}\n").unwrap();

        // Generate stream interfaces for streaming methods
        for method in &s.methods {
            if let ServiceResponse::Stream(resp_ty) = &method.response.node {
                let method_name = to_pascal_case(&method.name.node);
                let response_type = self.go_type(resp_ty);
                writeln!(
                    self.output,
                    "// {}{}Stream is used to send streaming responses for the {} method.",
                    service_name, method_name, method.name.node
                )
                .unwrap();
                writeln!(self.output, "type {}{}Stream interface {{", service_name, method_name).unwrap();
                writeln!(self.output, "\tSend(item {}) error", response_type).unwrap();
                writeln!(self.output, "}}\n").unwrap();
            }
        }

        // Generate the handler struct
        writeln!(
            self.output,
            "// {}Handler wraps a {} implementation as a __rt.ServerHandler.",
            service_name, service_name
        )
        .unwrap();
        writeln!(
            self.output,
            "type {}Handler struct {{",
            service_name
        )
        .unwrap();
        writeln!(self.output, "\timpl {}", service_name).unwrap();
        writeln!(self.output, "}}\n").unwrap();

        writeln!(
            self.output,
            "// New{}Handler creates a new handler for the {} service.",
            service_name, service_name
        )
        .unwrap();
        writeln!(
            self.output,
            "func New{}Handler(impl {}) *{}Handler {{",
            service_name, service_name, service_name
        )
        .unwrap();
        writeln!(
            self.output,
            "\treturn &{}Handler{{impl: impl}}",
            service_name
        )
        .unwrap();
        writeln!(self.output, "}}\n").unwrap();

        // Generate HandleCall method
        writeln!(
            self.output,
            "func (h *{}Handler) HandleCall(call __rt.ServerCall) {{",
            service_name
        )
        .unwrap();
        writeln!(self.output, "\tswitch call.MethodIndex() {{").unwrap();

        for method in &s.methods {
            let method_name = to_pascal_case(&method.name.node);
            let index = method.index.node;

            writeln!(self.output, "\tcase {}:", index).unwrap();
            writeln!(self.output, "\t\tbuf := call.Payload()").unwrap();
            writeln!(
                self.output,
                "\t\treq, err := {}",
                self.decode_for_service(&method.request.node, "&buf")
            )
            .unwrap();
            writeln!(self.output, "\t\tif err != nil {{").unwrap();
            writeln!(
                self.output,
                "\t\t\tcall.SendError(__rt.ErrCodeDecodeError, err.Error())"
            )
            .unwrap();
            writeln!(self.output, "\t\t\treturn").unwrap();
            writeln!(self.output, "\t\t}}").unwrap();

            match &method.response.node {
                ServiceResponse::Unary(resp_ty) => {
                    writeln!(
                        self.output,
                        "\t\tresp, err := h.impl.{}(call.Context(), req)",
                        method_name
                    )
                    .unwrap();
                    writeln!(self.output, "\t\tif err != nil {{").unwrap();
                    writeln!(
                        self.output,
                        "\t\t\tcall.SendError(__rt.ErrCodeHandlerError, err.Error())"
                    )
                    .unwrap();
                    writeln!(self.output, "\t\t\treturn").unwrap();
                    writeln!(self.output, "\t\t}}").unwrap();
                    writeln!(self.output, "\t\tvar respBuf []byte").unwrap();
                    self.encode_value_for_service("resp", resp_ty, 2, "respBuf");
                    writeln!(self.output, "\t\tcall.SendResponse(respBuf)").unwrap();
                }
                ServiceResponse::Stream(_) => {
                    writeln!(
                        self.output,
                        "\t\tstream := &{}{}ServerStream{{call: call}}",
                        service_name, method_name
                    )
                    .unwrap();
                    writeln!(
                        self.output,
                        "\t\terr = h.impl.{}(call.Context(), req, stream)",
                        method_name
                    )
                    .unwrap();
                    writeln!(self.output, "\t\tif err != nil {{").unwrap();
                    writeln!(
                        self.output,
                        "\t\t\tcall.SendError(__rt.ErrCodeHandlerError, err.Error())"
                    )
                    .unwrap();
                    writeln!(self.output, "\t\t\treturn").unwrap();
                    writeln!(self.output, "\t\t}}").unwrap();
                    writeln!(self.output, "\t\tcall.SendStreamEnd()").unwrap();
                }
            }
        }

        writeln!(self.output, "\tdefault:").unwrap();
        writeln!(
            self.output,
            "\t\tcall.SendError(__rt.ErrCodeUnknownMethod, \"unknown method\")"
        )
        .unwrap();
        writeln!(self.output, "\t}}").unwrap();
        writeln!(self.output, "}}\n").unwrap();

        // Generate stream sender structs for streaming methods
        for method in &s.methods {
            if let ServiceResponse::Stream(resp_ty) = &method.response.node {
                let method_name = to_pascal_case(&method.name.node);
                let response_type = self.go_type(resp_ty);

                writeln!(
                    self.output,
                    "type {}{}ServerStream struct {{",
                    service_name, method_name
                )
                .unwrap();
                writeln!(self.output, "\tcall __rt.ServerCall").unwrap();
                writeln!(self.output, "}}\n").unwrap();

                writeln!(
                    self.output,
                    "func (s *{}{}ServerStream) Send(item {}) error {{",
                    service_name, method_name, response_type
                )
                .unwrap();
                writeln!(self.output, "\tvar buf []byte").unwrap();
                self.encode_value_for_service("item", resp_ty, 1, "buf");
                writeln!(self.output, "\treturn s.call.SendStreamItem(buf)").unwrap();
                writeln!(self.output, "}}\n").unwrap();
            }
        }

        // Generate the client struct
        writeln!(
            self.output,
            "// {}Client is a client for the {} service.",
            service_name, service_name
        )
        .unwrap();
        writeln!(self.output, "type {}Client struct {{", service_name).unwrap();
        writeln!(self.output, "\ttransport __rt.ClientTransport").unwrap();
        writeln!(self.output, "}}\n").unwrap();

        // Generate client constructor
        writeln!(
            self.output,
            "// New{}Client creates a new client for the {} service.",
            service_name, service_name
        )
        .unwrap();
        writeln!(
            self.output,
            "func New{}Client(transport __rt.ClientTransport) *{}Client {{",
            service_name, service_name
        )
        .unwrap();
        writeln!(self.output, "\treturn &{}Client{{", service_name).unwrap();
        writeln!(self.output, "\t\ttransport: transport,").unwrap();
        writeln!(self.output, "\t}}").unwrap();
        writeln!(self.output, "}}\n").unwrap();

        // Generate client methods
        for method in &s.methods {
            let method_name = to_pascal_case(&method.name.node);
            let request_type = self.go_type(&method.request.node);
            let index = method.index.node;

            match &method.response.node {
                ServiceResponse::Unary(resp_ty) => {
                    let response_type = self.go_type(resp_ty);

                    writeln!(self.output, "// {} calls the {} method.", method_name, method.name.node).unwrap();
                    writeln!(
                        self.output,
                        "func (c *{}Client) {}(ctx context.Context, req {}) ({}, error) {{",
                        service_name, method_name, request_type, response_type
                    )
                    .unwrap();

                    // Encode the request
                    writeln!(self.output, "\tvar reqBuf []byte").unwrap();
                    self.encode_value_for_service("req", &method.request.node, 1, "reqBuf");

                    // Make the call
                    writeln!(
                        self.output,
                        "\trespBuf, err := c.transport.CallUnary(ctx, {}, reqBuf)",
                        index
                    )
                    .unwrap();
                    writeln!(self.output, "\tif err != nil {{").unwrap();
                    writeln!(self.output, "\t\tvar zero {}", response_type).unwrap();
                    writeln!(self.output, "\t\treturn zero, err").unwrap();
                    writeln!(self.output, "\t}}").unwrap();

                    // Decode the response
                    writeln!(
                        self.output,
                        "\tresp, err := {}",
                        self.decode_for_service(resp_ty, "&respBuf")
                    )
                    .unwrap();
                    writeln!(self.output, "\tif err != nil {{").unwrap();
                    writeln!(self.output, "\t\tvar zero {}", response_type).unwrap();
                    writeln!(self.output, "\t\treturn zero, err").unwrap();
                    writeln!(self.output, "\t}}").unwrap();
                    writeln!(self.output, "\treturn resp, nil").unwrap();
                    writeln!(self.output, "}}\n").unwrap();
                }
                ServiceResponse::Stream(resp_ty) => {
                    let response_type = self.go_type(resp_ty);

                    writeln!(
                        self.output,
                        "// {} calls the {} method and returns a stream receiver.",
                        method_name, method.name.node
                    )
                    .unwrap();
                    writeln!(
                        self.output,
                        "func (c *{}Client) {}(ctx context.Context, req {}) (*{}{}ClientStream, error) {{",
                        service_name, method_name, request_type, service_name, method_name
                    )
                    .unwrap();

                    // Encode the request
                    writeln!(self.output, "\tvar reqBuf []byte").unwrap();
                    self.encode_value_for_service("req", &method.request.node, 1, "reqBuf");

                    // Make the call
                    writeln!(
                        self.output,
                        "\treceiver, err := c.transport.CallStream(ctx, {}, reqBuf)",
                        index
                    )
                    .unwrap();
                    writeln!(self.output, "\tif err != nil {{").unwrap();
                    writeln!(self.output, "\t\treturn nil, err").unwrap();
                    writeln!(self.output, "\t}}").unwrap();

                    writeln!(
                        self.output,
                        "\treturn &{}{}ClientStream{{receiver: receiver}}, nil",
                        service_name, method_name
                    )
                    .unwrap();
                    writeln!(self.output, "}}\n").unwrap();

                    // Generate client stream struct
                    writeln!(
                        self.output,
                        "// {}{}ClientStream receives streaming responses.",
                        service_name, method_name
                    )
                    .unwrap();
                    writeln!(
                        self.output,
                        "type {}{}ClientStream struct {{",
                        service_name, method_name
                    )
                    .unwrap();
                    writeln!(self.output, "\treceiver *__rt.StreamReceiver").unwrap();
                    writeln!(self.output, "}}\n").unwrap();

                    // Generate Recv method
                    writeln!(
                        self.output,
                        "// Recv receives the next item from the stream. Returns ({}, __rt.ErrStreamClosed) when the stream ends.",
                        response_type
                    )
                    .unwrap();
                    writeln!(
                        self.output,
                        "func (s *{}{}ClientStream) Recv() ({}, error) {{",
                        service_name, method_name, response_type
                    )
                    .unwrap();
                    writeln!(self.output, "\tdata, err := s.receiver.Recv()").unwrap();
                    writeln!(self.output, "\tif err != nil {{").unwrap();
                    writeln!(self.output, "\t\tvar zero {}", response_type).unwrap();
                    writeln!(self.output, "\t\treturn zero, err").unwrap();
                    writeln!(self.output, "\t}}").unwrap();
                    writeln!(self.output, "\tbuf := data").unwrap();
                    writeln!(
                        self.output,
                        "\tresp, err := {}",
                        self.decode_for_service(resp_ty, "&buf")
                    )
                    .unwrap();
                    writeln!(self.output, "\tif err != nil {{").unwrap();
                    writeln!(self.output, "\t\tvar zero {}", response_type).unwrap();
                    writeln!(self.output, "\t\treturn zero, err").unwrap();
                    writeln!(self.output, "\t}}").unwrap();
                    writeln!(self.output, "\treturn resp, nil").unwrap();
                    writeln!(self.output, "}}").unwrap();
                }
            }
        }
    }

    fn decode_for_service(&self, ty: &Type, buf_var: &str) -> String {
        match ty {
            Type::Named(name) => format!("Decode{}({})", name, buf_var),
            Type::Bool => format!("__rt.DecodeBool({})", buf_var),
            Type::U8 => format!("__rt.DecodeU8({})", buf_var),
            Type::U16 => format!("__rt.DecodeU16({})", buf_var),
            Type::U32 => format!("__rt.DecodeU32({})", buf_var),
            Type::U64 => format!("__rt.DecodeU64({})", buf_var),
            Type::I8 => format!("__rt.DecodeI8({})", buf_var),
            Type::I16 => format!("__rt.DecodeI16({})", buf_var),
            Type::I32 => format!("__rt.DecodeI32({})", buf_var),
            Type::I64 => format!("__rt.DecodeI64({})", buf_var),
            Type::F32 => format!("__rt.DecodeF32({})", buf_var),
            Type::F64 => format!("__rt.DecodeF64({})", buf_var),
            Type::String => format!("__rt.DecodeString({})", buf_var),
            Type::Array(_) | Type::Map(_, _) => panic!("Array/Map types not supported for RPC"),
        }
    }

    fn encode_value_for_service(&mut self, value: &str, ty: &Type, indent: usize, buf_var: &str) {
        let tabs = "\t".repeat(indent);
        // For services, we always encode the full value (not inside a BYTES field)
        match ty {
            Type::Named(_) => {
                writeln!(self.output, "{}{}.Encode(&{})", tabs, value, buf_var).unwrap();
            }
            _ => {
                // For primitive types, use the standard encode functions with the proper buffer
                self.encode_value_to_buf(value, ty, indent, &format!("&{}", buf_var), false);
            }
        }
    }
}

fn to_pascal_case(s: &str) -> String {
    s.split('_')
        .map(|word| {
            let mut chars = word.chars();
            match chars.next() {
                None => String::new(),
                Some(first) => first.to_uppercase().collect::<String>() + chars.as_str(),
            }
        })
        .collect()
}
