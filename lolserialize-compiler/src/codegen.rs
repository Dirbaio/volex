//! Code generator for lolserialize schemas.

use std::fmt::Write;

use crate::schema::*;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum DerivableTrait {
    Debug,
    Clone,
    Copy,
    PartialEq,
    Eq,
    Hash,
    Default,
}

pub fn generate(schema: &Schema) -> String {
    let generator = CodeGenerator::new(schema);
    generator.generate()
}

struct CodeGenerator<'a> {
    schema: &'a Schema,
    output: String,
}

impl<'a> CodeGenerator<'a> {
    fn new(schema: &'a Schema) -> Self {
        Self {
            schema,
            output: String::new(),
        }
    }

    fn generate(mut self) -> String {
        self.output.push_str("// Generated by lolserialize. Do not edit.\n\n");
        self.output.push_str("use lolserialize_runtime as __rt;\n\n");

        for item in &self.schema.items {
            match &item.node {
                Item::Struct(s) => self.gen_struct(s),
                Item::Message(m) => self.gen_message(m),
                Item::Enum(e) => self.gen_enum(e),
                Item::Union(u) => self.gen_union(u),
            }
            self.output.push('\n');
        }

        self.output
    }

    fn rust_type(&self, ty: &Type) -> String {
        match ty {
            Type::Bool => "bool".to_string(),
            Type::U8 => "u8".to_string(),
            Type::U16 => "u16".to_string(),
            Type::U32 => "u32".to_string(),
            Type::U64 => "u64".to_string(),
            Type::I8 => "i8".to_string(),
            Type::I16 => "i16".to_string(),
            Type::I32 => "i32".to_string(),
            Type::I64 => "i64".to_string(),
            Type::F32 => "f32".to_string(),
            Type::F64 => "f64".to_string(),
            Type::String => "::std::string::String".to_string(),
            Type::Array(inner) => format!("::std::vec::Vec<{}>", self.rust_type(&inner.node)),
            Type::Map(k, v) => {
                format!(
                    "::std::collections::HashMap<{}, {}>",
                    self.rust_type(&k.node),
                    self.rust_type(&v.node)
                )
            }
            Type::Named(name) => name.clone(),
        }
    }

    /// Returns true if the item can derive the specified trait.
    fn can_derive_item(&self, item: &Item, trait_: DerivableTrait) -> bool {
        match item {
            Item::Struct(i) => i.fields.iter().all(|f| self.can_derive(&f.ty.node, trait_)),
            Item::Message(i) => i.fields.iter().all(|f| self.can_derive(&f.ty.node, trait_)),
            Item::Union(i) => i
                .variants
                .iter()
                .flat_map(|x| &x.node.ty)
                .all(|ty| self.can_derive(ty, trait_)),
            Item::Enum(_) => true,
        }
    }

    /// Returns true if the type can derive the specified trait.
    fn can_derive(&self, ty: &Type, trait_: DerivableTrait) -> bool {
        match ty {
            Type::Bool
            | Type::U8
            | Type::U16
            | Type::U32
            | Type::U64
            | Type::I8
            | Type::I16
            | Type::I32
            | Type::I64 => true,
            Type::F32 | Type::F64 => match trait_ {
                DerivableTrait::Eq | DerivableTrait::Hash => false,
                _ => true,
            },
            Type::String => match trait_ {
                DerivableTrait::Copy => false,
                _ => true,
            },
            Type::Array(t) => match trait_ {
                DerivableTrait::Copy => false,
                _ => self.can_derive(t, trait_),
            },
            Type::Map(k, v) => match trait_ {
                DerivableTrait::Copy => false,
                DerivableTrait::Hash => false,
                _ => self.can_derive(k, trait_) && self.can_derive(v, trait_),
            },
            Type::Named(name) => self.can_derive_item(self.schema.item(name).unwrap(), trait_),
        }
    }

    /// Generates a #[derive(...)] attribute.
    fn gen_derive_attr(&mut self, item: &Item) {
        let mut derivable_traits = Vec::new();
        for trait_ in [
            DerivableTrait::Debug,
            DerivableTrait::Copy,
            DerivableTrait::Clone,
            DerivableTrait::PartialEq,
            DerivableTrait::Eq,
            DerivableTrait::Hash,
            DerivableTrait::Default,
        ] {
            // unions generate a Default impl manually.
            if trait_ == DerivableTrait::Default && matches!(item, Item::Union(_)) {
                continue;
            }

            if self.can_derive_item(item, trait_) {
                let trait_name = match trait_ {
                    DerivableTrait::Debug => "Debug",
                    DerivableTrait::Clone => "Clone",
                    DerivableTrait::Copy => "Copy",
                    DerivableTrait::PartialEq => "PartialEq",
                    DerivableTrait::Eq => "Eq",
                    DerivableTrait::Hash => "Hash",
                    DerivableTrait::Default => "Default",
                };
                derivable_traits.push(trait_name);
            }
        }

        if !derivable_traits.is_empty() {
            write!(self.output, "#[derive({})]", derivable_traits.join(", ")).unwrap();
            self.output.push('\n');
        }
    }

    fn gen_struct(&mut self, s: &Struct) {
        let name = &s.name.node;

        // Generate struct definition
        self.gen_derive_attr(&Item::Struct(s.clone()));
        writeln!(
            self.output,
            "#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]"
        )
        .unwrap();
        writeln!(self.output, "pub struct {} {{", name).unwrap();
        for field in &s.fields {
            let field_name = &field.name.node;
            let field_type = self.rust_type(&field.ty.node);
            if field.optional {
                writeln!(
                    self.output,
                    "    pub {}: ::core::option::Option<{}>,",
                    field_name, field_type
                )
                .unwrap();
            } else {
                writeln!(self.output, "    pub {}: {},", field_name, field_type).unwrap();
            }
        }
        writeln!(self.output, "}}").unwrap();
        self.output.push('\n');

        // Count optional fields
        let optional_fields: Vec<_> = s.fields.iter().filter(|f| f.optional).collect();
        let has_optionals = !optional_fields.is_empty();

        // Generate Encode impl
        writeln!(self.output, "impl __rt::Encode for {} {{", name).unwrap();
        writeln!(self.output, "    fn encode(&self, buf: &mut ::std::vec::Vec<u8>) {{").unwrap();

        if has_optionals {
            // Encode presence bits
            write!(self.output, "        __rt::encode_presence_bits(&[").unwrap();
            for (i, field) in optional_fields.iter().enumerate() {
                if i > 0 {
                    write!(self.output, ", ").unwrap();
                }
                write!(self.output, "self.{}.is_some()", field.name.node).unwrap();
            }
            writeln!(self.output, "], buf);").unwrap();
        }

        // Encode fields in order
        for field in &s.fields {
            let field_name = &field.name.node;
            if field.optional {
                writeln!(
                    self.output,
                    "        if let Some(ref v) = self.{} {{ __rt::Encode::encode(v, buf); }}",
                    field_name
                )
                .unwrap();
            } else {
                writeln!(self.output, "        __rt::Encode::encode(&self.{}, buf);", field_name).unwrap();
            }
        }

        writeln!(self.output, "    }}").unwrap();
        writeln!(self.output, "}}").unwrap();
        self.output.push('\n');

        // Generate Decode impl
        writeln!(self.output, "impl __rt::Decode for {} {{", name).unwrap();
        writeln!(
            self.output,
            "    fn decode(buf: &mut &[u8]) -> ::core::result::Result<Self, __rt::DecodeError> {{"
        )
        .unwrap();

        if has_optionals {
            writeln!(
                self.output,
                "        let presence = __rt::decode_presence_bits({}, buf)?;",
                optional_fields.len()
            )
            .unwrap();
        }

        // Decode fields in order
        let mut opt_idx = 0;
        for field in &s.fields {
            let field_name = &field.name.node;
            let field_type = self.rust_type(&field.ty.node);
            if field.optional {
                writeln!(
                    self.output,
                    "        let {} = if presence[{}] {{ ::core::option::Option::Some(<{}>::decode(buf)?) }} else {{ ::core::option::Option::None }};",
                    field_name, opt_idx, field_type
                )
                .unwrap();
                opt_idx += 1;
            } else {
                writeln!(
                    self.output,
                    "        let {} = <{}>::decode(buf)?;",
                    field_name, field_type
                )
                .unwrap();
            }
        }

        writeln!(self.output, "        ::core::result::Result::Ok(Self {{").unwrap();
        for field in &s.fields {
            writeln!(self.output, "            {},", field.name.node).unwrap();
        }
        writeln!(self.output, "        }})").unwrap();
        writeln!(self.output, "    }}").unwrap();
        writeln!(self.output, "}}").unwrap();
        self.output.push('\n');

        // Generate WireType impl (structs use BYTES)
        writeln!(self.output, "impl __rt::WireType for {} {{", name).unwrap();
        writeln!(self.output, "    const WIRE_TYPE: u8 = __rt::wire::BYTES;").unwrap();
        if let Some(size) = self.schema.struct_fixed_size(s) {
            writeln!(
                self.output,
                "    const FIXED_SIZE: ::core::option::Option<usize> = ::core::option::Option::Some({});",
                size
            )
            .unwrap();
        }
        writeln!(self.output, "}}").unwrap();
    }

    fn gen_message(&mut self, m: &Message) {
        let name = &m.name.node;

        // Generate struct definition
        self.gen_derive_attr(&Item::Message(m.clone()));
        writeln!(
            self.output,
            "#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]"
        )
        .unwrap();
        writeln!(self.output, "pub struct {} {{", name).unwrap();
        for field in &m.fields {
            let field_name = &field.name.node;
            let field_type = self.rust_type(&field.ty.node);
            if field.optional {
                writeln!(
                    self.output,
                    "    pub {}: ::core::option::Option<{}>,",
                    field_name, field_type
                )
                .unwrap();
            } else {
                writeln!(self.output, "    pub {}: {},", field_name, field_type).unwrap();
            }
        }
        writeln!(self.output, "}}").unwrap();
        self.output.push('\n');

        // Generate Encode impl
        writeln!(self.output, "impl __rt::Encode for {} {{", name).unwrap();
        writeln!(self.output, "    fn encode(&self, buf: &mut ::std::vec::Vec<u8>) {{").unwrap();

        // Encode fields in index order
        let mut fields_sorted: Vec<_> = m.fields.iter().collect();
        fields_sorted.sort_by_key(|f| f.index.node);

        for field in &fields_sorted {
            let field_name = &field.name.node;
            let index = field.index.node;
            if field.optional {
                writeln!(
                    self.output,
                    "        if let Some(ref v) = self.{} {{ __rt::encode_field({}, v, buf); }}",
                    field_name, index
                )
                .unwrap();
            } else {
                writeln!(
                    self.output,
                    "        __rt::encode_field({}, &self.{}, buf);",
                    index, field_name
                )
                .unwrap();
            }
        }

        writeln!(self.output, "        __rt::encode_message_end(buf);").unwrap();
        writeln!(self.output, "    }}").unwrap();
        writeln!(self.output, "}}").unwrap();
        self.output.push('\n');

        // Generate Decode impl
        writeln!(self.output, "impl __rt::Decode for {} {{", name).unwrap();
        writeln!(
            self.output,
            "    fn decode(buf: &mut &[u8]) -> ::core::result::Result<Self, __rt::DecodeError> {{"
        )
        .unwrap();
        writeln!(self.output, "        let mut result = Self::default();").unwrap();
        writeln!(
            self.output,
            "        while let ::core::option::Option::Some((index, wire_type)) = __rt::decode_tag(buf)? {{"
        )
        .unwrap();
        writeln!(self.output, "            match index {{").unwrap();

        for field in &m.fields {
            let field_name = &field.name.node;
            let index = field.index.node;
            if field.optional {
                writeln!(
                    self.output,
                    "                {} => result.{} = ::core::option::Option::Some(__rt::decode_field(buf)?),",
                    index, field_name
                )
                .unwrap();
            } else {
                writeln!(
                    self.output,
                    "                {} => result.{} = __rt::decode_field(buf)?,",
                    index, field_name
                )
                .unwrap();
            }
        }

        writeln!(
            self.output,
            "                _ => __rt::skip_by_wire_type(wire_type, buf)?,"
        )
        .unwrap();
        writeln!(self.output, "            }}").unwrap();
        writeln!(self.output, "        }}").unwrap();
        writeln!(self.output, "        ::core::result::Result::Ok(result)").unwrap();
        writeln!(self.output, "    }}").unwrap();
        writeln!(self.output, "}}").unwrap();
        self.output.push('\n');

        // Generate WireType impl (messages use MESSAGE)
        writeln!(self.output, "impl __rt::WireType for {} {{", name).unwrap();
        writeln!(self.output, "    const WIRE_TYPE: u8 = __rt::wire::MESSAGE;").unwrap();
        writeln!(self.output, "}}").unwrap();
    }

    fn gen_enum(&mut self, e: &Enum) {
        let name = &e.name.node;

        // Generate enum definition
        self.gen_derive_attr(&Item::Enum(e.clone()));
        writeln!(
            self.output,
            "#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]"
        )
        .unwrap();
        writeln!(self.output, "pub enum {} {{", name).unwrap();
        for (i, variant) in e.variants.iter().enumerate() {
            if i == 0 {
                // first variant is the default.
                writeln!(self.output, "    #[default]").unwrap();
            }
            writeln!(self.output, "    {},", variant.name.node).unwrap();
        }
        writeln!(self.output, "}}").unwrap();
        self.output.push('\n');

        // Generate Encode impl
        writeln!(self.output, "impl __rt::Encode for {} {{", name).unwrap();
        writeln!(self.output, "    fn encode(&self, buf: &mut ::std::vec::Vec<u8>) {{").unwrap();
        writeln!(self.output, "        let index: u32 = match self {{").unwrap();
        for variant in &e.variants {
            writeln!(
                self.output,
                "            Self::{} => {},",
                variant.name.node, variant.index.node
            )
            .unwrap();
        }
        writeln!(self.output, "        }};").unwrap();
        writeln!(self.output, "        __rt::Encode::encode(&index, buf);").unwrap();
        writeln!(self.output, "    }}").unwrap();
        writeln!(self.output, "}}").unwrap();
        self.output.push('\n');

        // Generate Decode impl
        writeln!(self.output, "impl __rt::Decode for {} {{", name).unwrap();
        writeln!(
            self.output,
            "    fn decode(buf: &mut &[u8]) -> ::core::result::Result<Self, __rt::DecodeError> {{"
        )
        .unwrap();
        writeln!(self.output, "        let index = <u32>::decode(buf)?;").unwrap();
        writeln!(self.output, "        match index {{").unwrap();
        for variant in &e.variants {
            writeln!(
                self.output,
                "            {} => ::core::result::Result::Ok(Self::{}),",
                variant.index.node, variant.name.node
            )
            .unwrap();
        }
        writeln!(
            self.output,
            "            _ => ::core::result::Result::Err(__rt::DecodeError::UnknownEnumVariant(index)),"
        )
        .unwrap();
        writeln!(self.output, "        }}").unwrap();
        writeln!(self.output, "    }}").unwrap();
        writeln!(self.output, "}}").unwrap();
        self.output.push('\n');

        // Generate WireType impl (enums use VARINT)
        writeln!(self.output, "impl __rt::WireType for {} {{", name).unwrap();
        writeln!(self.output, "    const WIRE_TYPE: u8 = __rt::wire::VARINT;").unwrap();
        writeln!(self.output, "}}").unwrap();
    }

    fn gen_union(&mut self, u: &Union) {
        let name = &u.name.node;

        // Generate enum definition
        self.gen_derive_attr(&Item::Union(u.clone()));
        writeln!(
            self.output,
            "#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]"
        )
        .unwrap();
        writeln!(
            self.output,
            "#[cfg_attr(feature = \"serde\", serde(tag = \"$tag\", content = \"$value\"))]"
        )
        .unwrap();
        writeln!(self.output, "pub enum {} {{", name).unwrap();
        for variant in &u.variants {
            let variant_name = &variant.name.node;
            if let Some(ty) = &variant.ty {
                writeln!(self.output, "    {}({}),", variant_name, self.rust_type(&ty.node)).unwrap();
            } else {
                writeln!(self.output, "    {},", variant_name).unwrap();
            }
        }
        writeln!(self.output, "}}").unwrap();
        self.output.push('\n');

        // Generate Default impl (first variant)
        if let Some(first) = u.variants.first() {
            writeln!(self.output, "impl ::core::default::Default for {} {{", name).unwrap();
            writeln!(self.output, "    fn default() -> Self {{").unwrap();
            if first.ty.is_some() {
                writeln!(
                    self.output,
                    "        Self::{}(::core::default::Default::default())",
                    first.name.node
                )
                .unwrap();
            } else {
                writeln!(self.output, "        Self::{}", first.node.name.node).unwrap();
            }
            writeln!(self.output, "    }}").unwrap();
            writeln!(self.output, "}}").unwrap();
            self.output.push('\n');
        }

        // Generate Encode impl
        writeln!(self.output, "impl __rt::Encode for {} {{", name).unwrap();
        writeln!(self.output, "    fn encode(&self, buf: &mut ::std::vec::Vec<u8>) {{").unwrap();
        writeln!(self.output, "        match self {{").unwrap();
        for variant in &u.variants {
            let variant_name = &variant.name.node;
            let index = variant.index.node;
            if variant.ty.is_some() {
                writeln!(
                    self.output,
                    "            Self::{}(v) => __rt::encode_field({}, v, buf),",
                    variant_name, index
                )
                .unwrap();
            } else {
                // Unit variant: just encode tag with UNIT wire type
                let tag = (index << 3) | 7; // 7 = wire::UNIT
                writeln!(
                    self.output,
                    "            Self::{} => __rt::encode_leb128_u64({}, buf),",
                    variant_name, tag
                )
                .unwrap();
            }
        }
        writeln!(self.output, "        }}").unwrap();
        writeln!(self.output, "    }}").unwrap();
        writeln!(self.output, "}}").unwrap();
        self.output.push('\n');

        // Generate Decode impl
        writeln!(self.output, "impl __rt::Decode for {} {{", name).unwrap();
        writeln!(
            self.output,
            "    fn decode(buf: &mut &[u8]) -> ::core::result::Result<Self, __rt::DecodeError> {{"
        )
        .unwrap();
        writeln!(self.output, "        let tag = __rt::decode_leb128_u64(buf)?;").unwrap();
        writeln!(self.output, "        let index = (tag >> 3) as u32;").unwrap();
        writeln!(self.output, "        match index {{").unwrap();
        for variant in &u.variants {
            let variant_name = &variant.name.node;
            let index = variant.index.node;
            if variant.ty.is_some() {
                writeln!(
                    self.output,
                    "            {} => ::core::result::Result::Ok(Self::{}(__rt::decode_field(buf)?)),",
                    index, variant_name
                )
                .unwrap();
            } else {
                // Unit variant: nothing to decode (UNIT wire type has no payload)
                writeln!(
                    self.output,
                    "            {} => ::core::result::Result::Ok(Self::{}),",
                    index, variant_name
                )
                .unwrap();
            }
        }
        writeln!(
            self.output,
            "            _ => ::core::result::Result::Err(__rt::DecodeError::UnknownUnionVariant(index)),"
        )
        .unwrap();
        writeln!(self.output, "        }}").unwrap();
        writeln!(self.output, "    }}").unwrap();
        writeln!(self.output, "}}").unwrap();
        self.output.push('\n');

        // Generate WireType impl (unions use UNION)
        writeln!(self.output, "impl __rt::WireType for {} {{", name).unwrap();
        writeln!(self.output, "    const WIRE_TYPE: u8 = __rt::wire::UNION;").unwrap();
        writeln!(self.output, "}}").unwrap();
    }
}
