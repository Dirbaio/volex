//! Go code generator for lolserialize schemas.

use std::fmt::Write;

use crate::schema::*;

pub fn generate(schema: &Schema, package_name: &str) -> String {
    let generator = GoCodeGenerator::new(schema, package_name);
    generator.generate()
}

struct GoCodeGenerator<'a> {
    schema: &'a Schema,
    package_name: &'a str,
    output: String,
    enum_names: std::collections::HashSet<String>,
    union_names: std::collections::HashSet<String>,
}

impl<'a> GoCodeGenerator<'a> {
    fn new(schema: &'a Schema, package_name: &'a str) -> Self {
        // Collect all enum and union names
        let mut enum_names = std::collections::HashSet::new();
        let mut union_names = std::collections::HashSet::new();
        for item in &schema.items {
            match &item.node {
                Item::Enum(e) => {
                    enum_names.insert(e.name.node.clone());
                }
                Item::Union(u) => {
                    union_names.insert(u.name.node.clone());
                }
                _ => {}
            }
        }

        Self {
            schema,
            package_name,
            output: String::new(),
            enum_names,
            union_names,
        }
    }

    fn generate(mut self) -> String {
        self.output
            .push_str("// Code generated by lolserialize. DO NOT EDIT.\n\n");
        writeln!(self.output, "package {}\n", self.package_name).unwrap();

        // Check if we need encoding/json (for enums, unions, structs/messages with []uint8 fields)
        let needs_json = self.schema.items.iter().any(|item| {
            match &item.node {
                Item::Enum(_) | Item::Union(_) => true,
                Item::Struct(s) => s.fields.iter().any(|f| {
                    matches!(&f.node.ty.node, Type::Array(inner) if matches!(&inner.node, Type::U8))
                }),
                Item::Message(m) => m.fields.iter().any(|f| {
                    matches!(&f.node.ty.node, Type::Array(inner) if matches!(&inner.node, Type::U8))
                }),
                _ => false,
            }
        });

        self.output.push_str("import (\n");
        if needs_json {
            self.output.push_str("\t\"encoding/json\"\n");
        }
        self.output.push_str("\t. \"github.com/lolserialize/runtime\"\n");
        self.output.push_str(")\n\n");

        for item in &self.schema.items {
            match &item.node {
                Item::Struct(s) => self.gen_struct(s),
                Item::Message(m) => self.gen_message(m),
                Item::Enum(e) => self.gen_enum(e),
                Item::Union(u) => self.gen_union(u),
            }
            self.output.push('\n');
        }

        self.output
    }

    fn go_type(&self, ty: &Type) -> String {
        match ty {
            Type::Bool => "bool".to_string(),
            Type::U8 => "uint8".to_string(),
            Type::U16 => "uint16".to_string(),
            Type::U32 => "uint32".to_string(),
            Type::U64 => "uint64".to_string(),
            Type::I8 => "int8".to_string(),
            Type::I16 => "int16".to_string(),
            Type::I32 => "int32".to_string(),
            Type::I64 => "int64".to_string(),
            Type::F32 => "float32".to_string(),
            Type::F64 => "float64".to_string(),
            Type::String => "string".to_string(),
            Type::Array(inner) => format!("[]{}", self.go_type(&inner.node)),
            Type::Map(k, v) => format!("map[{}]{}", self.go_type(&k.node), self.go_type(&v.node)),
            Type::Named(name) => {
                // All named types (enums, structs, messages) are value types
                // Unions are interfaces which are reference types
                name.clone()
            }
        }
    }

    fn go_type_optional(&self, ty: &Type) -> String {
        // Optional types are always pointers
        format!("*{}", self.go_type(ty))
    }

    fn gen_struct(&mut self, s: &Struct) {
        writeln!(self.output, "type {} struct {{", s.name.node).unwrap();

        for field in &s.fields {
            let ty = if field.node.optional {
                self.go_type_optional(&field.node.ty.node)
            } else {
                self.go_type(&field.node.ty.node)
            };
            // Don't use omitempty - we want to serialize null for optional fields
            writeln!(
                self.output,
                "\t{} {} `json:\"{}\"`",
                to_pascal_case(&field.node.name.node),
                ty,
                &field.node.name.node
            )
            .unwrap();
        }

        self.output.push_str("}\n\n");

        // Generate Encode method
        writeln!(self.output, "func (s *{}) Encode(buf *[]byte) {{", s.name.node).unwrap();

        // Handle optional fields - encode presence bits first
        let optional_fields: Vec<_> = s.fields.iter().filter(|f| f.node.optional).collect();
        if !optional_fields.is_empty() {
            self.output.push_str("\t// Encode presence bits\n");
            self.output.push_str("\tpresence := []bool{");
            for (i, field) in optional_fields.iter().enumerate() {
                if i > 0 {
                    self.output.push_str(", ");
                }
                write!(self.output, "s.{} != nil", to_pascal_case(&field.node.name.node)).unwrap();
            }
            self.output.push_str("}\n");
            self.output.push_str("\tEncodePresenceBits(presence, buf)\n\n");
        }

        // Encode each field
        for field in &s.fields {
            let field_name = to_pascal_case(&field.node.name.node);
            if field.node.optional {
                writeln!(self.output, "\tif s.{} != nil {{", field_name).unwrap();
                // For optional fields, we need to dereference the pointer
                // Use parentheses to avoid ambiguity with method calls
                self.encode_value(&format!("(*s.{})", field_name), &field.node.ty.node, 2);
                self.output.push_str("\t}\n");
            } else {
                self.encode_value(&format!("s.{}", field_name), &field.node.ty.node, 1);
            }
        }

        self.output.push_str("}\n\n");

        // Generate Decode method
        writeln!(
            self.output,
            "func Decode{}(buf *[]byte) ({}, error) {{",
            s.name.node, s.name.node
        )
        .unwrap();
        // Only declare err if we have fields to decode
        if !s.fields.is_empty() {
            writeln!(self.output, "\tvar err error").unwrap();
        }
        writeln!(self.output, "\tvar result {}", s.name.node).unwrap();

        // Handle optional fields - decode presence bits first
        if !optional_fields.is_empty() {
            writeln!(self.output, "\tvar presence []bool").unwrap();
            writeln!(
                self.output,
                "\tpresence, err = DecodePresenceBits({}, buf)",
                optional_fields.len()
            )
            .unwrap();
            writeln!(self.output, "\tif err != nil {{").unwrap();
            writeln!(self.output, "\t\treturn {}{{}}, err", s.name.node).unwrap();
            writeln!(self.output, "\t}}").unwrap();
            self.output.push('\n');
        }

        // Decode each field
        let mut presence_idx = 0;
        for field in &s.fields {
            let field_name = to_pascal_case(&field.node.name.node);
            if field.node.optional {
                writeln!(self.output, "\tif presence[{}] {{", presence_idx).unwrap();
                self.decode_value(&format!("result.{}", field_name), &field.node.ty.node, 2, true, &s.name.node);
                self.output.push_str("\t}\n");
                presence_idx += 1;
            } else {
                self.decode_value(&format!("result.{}", field_name), &field.node.ty.node, 1, false, &s.name.node);
            }
        }

        self.output.push_str("\treturn result, nil\n");
        self.output.push_str("}\n");

        // Generate custom JSON marshaling for structs with []uint8 or float fields
        self.gen_struct_json_marshaling(s);
    }

    fn gen_struct_json_marshaling(&mut self, s: &Struct) {
        // Check if any field needs custom marshaling ([]uint8)
        let has_u8_array = s.fields.iter().any(|f| {
            matches!(&f.node.ty.node, Type::Array(inner) if matches!(&inner.node, Type::U8))
        });

        if !has_u8_array {
            return;
        }

        // Generate MarshalJSON to convert []uint8 to JSON array instead of base64 string
        writeln!(self.output, "\nfunc (s {}) MarshalJSON() ([]byte, error) {{", s.name.node).unwrap();
        writeln!(self.output, "\ttype Alias {}", s.name.node).unwrap();
        writeln!(self.output, "\taux := &struct {{").unwrap();

        for field in &s.fields {
            let field_name = to_pascal_case(&field.node.name.node);
            if let Type::Array(inner) = &field.node.ty.node {
                if matches!(&inner.node, Type::U8) {
                    let ty = if field.node.optional {
                        "*[]interface{}".to_string()
                    } else {
                        "[]interface{}".to_string()
                    };
                    writeln!(self.output, "\t\t{} {} `json:\"{}\"`", field_name, ty, &field.node.name.node).unwrap();
                }
            }
        }

        writeln!(self.output, "\t\t*Alias").unwrap();
        writeln!(self.output, "\t}}{{").unwrap();
        writeln!(self.output, "\t\tAlias: (*Alias)(&s),").unwrap();
        writeln!(self.output, "\t}}").unwrap();

        for field in &s.fields {
            let field_name = to_pascal_case(&field.node.name.node);
            if let Type::Array(inner) = &field.node.ty.node {
                if matches!(&inner.node, Type::U8) {
                    if field.node.optional {
                        writeln!(self.output, "\tif s.{} != nil {{", field_name).unwrap();
                        writeln!(self.output, "\t\tarr := make([]interface{{}}, len(*s.{}))", field_name).unwrap();
                        writeln!(self.output, "\t\tfor i, v := range *s.{} {{", field_name).unwrap();
                        writeln!(self.output, "\t\t\tarr[i] = v").unwrap();
                        writeln!(self.output, "\t\t}}").unwrap();
                        writeln!(self.output, "\t\taux.{} = &arr", field_name).unwrap();
                        writeln!(self.output, "\t}}").unwrap();
                    } else {
                        writeln!(self.output, "\taux.{} = make([]interface{{}}, len(s.{}))", field_name, field_name).unwrap();
                        writeln!(self.output, "\tfor i, v := range s.{} {{", field_name).unwrap();
                        writeln!(self.output, "\t\taux.{}[i] = v", field_name).unwrap();
                        writeln!(self.output, "\t}}").unwrap();
                    }
                }
            }
        }

        writeln!(self.output, "\treturn json.Marshal(aux)").unwrap();
        writeln!(self.output, "}}").unwrap();

        // Generate UnmarshalJSON
        writeln!(self.output, "\nfunc (s *{}) UnmarshalJSON(data []byte) error {{", s.name.node).unwrap();
        writeln!(self.output, "\ttype Alias {}", s.name.node).unwrap();
        writeln!(self.output, "\taux := &struct {{").unwrap();

        for field in &s.fields {
            let field_name = to_pascal_case(&field.node.name.node);
            if let Type::Array(inner) = &field.node.ty.node {
                if matches!(&inner.node, Type::U8) {
                    let ty = if field.node.optional {
                        "*[]interface{}".to_string()
                    } else {
                        "[]interface{}".to_string()
                    };
                    writeln!(self.output, "\t\t{} {} `json:\"{}\"`", field_name, ty, &field.node.name.node).unwrap();
                }
            }
        }

        writeln!(self.output, "\t\t*Alias").unwrap();
        writeln!(self.output, "\t}}{{").unwrap();
        writeln!(self.output, "\t\tAlias: (*Alias)(s),").unwrap();
        writeln!(self.output, "\t}}").unwrap();

        writeln!(self.output, "\tif err := json.Unmarshal(data, &aux); err != nil {{").unwrap();
        writeln!(self.output, "\t\treturn err").unwrap();
        writeln!(self.output, "\t}}").unwrap();

        for field in &s.fields {
            let field_name = to_pascal_case(&field.node.name.node);
            if let Type::Array(inner) = &field.node.ty.node {
                if matches!(&inner.node, Type::U8) {
                    if field.node.optional {
                        writeln!(self.output, "\tif aux.{} != nil {{", field_name).unwrap();
                        writeln!(self.output, "\t\tarr := make([]uint8, len(*aux.{}))", field_name).unwrap();
                        writeln!(self.output, "\t\tfor i, v := range *aux.{} {{", field_name).unwrap();
                        writeln!(self.output, "\t\t\tif f, ok := v.(float64); ok {{ arr[i] = uint8(f) }}").unwrap();
                        writeln!(self.output, "\t\t}}").unwrap();
                        writeln!(self.output, "\t\ts.{} = &arr", field_name).unwrap();
                        writeln!(self.output, "\t}}").unwrap();
                    } else {
                        writeln!(self.output, "\tif aux.{} != nil {{", field_name).unwrap();
                        writeln!(self.output, "\t\ts.{} = make([]uint8, len(aux.{}))", field_name, field_name).unwrap();
                        writeln!(self.output, "\t\tfor i, v := range aux.{} {{", field_name).unwrap();
                        writeln!(self.output, "\t\t\tif f, ok := v.(float64); ok {{ s.{}[i] = uint8(f) }}", field_name).unwrap();
                        writeln!(self.output, "\t\t}}").unwrap();
                        writeln!(self.output, "\t}}").unwrap();
                    }
                }
            }
        }

        writeln!(self.output, "\treturn nil").unwrap();
        writeln!(self.output, "}}").unwrap();
    }

    fn gen_message(&mut self, m: &Message) {
        writeln!(self.output, "type {} struct {{", m.name.node).unwrap();

        for field in &m.fields {
            let ty = if field.node.optional {
                self.go_type_optional(&field.node.ty.node)
            } else {
                self.go_type(&field.node.ty.node)
            };
            // Don't use omitempty - we want to serialize null for optional fields
            writeln!(
                self.output,
                "\t{} {} `json:\"{}\"`",
                to_pascal_case(&field.node.name.node),
                ty,
                &field.node.name.node
            )
            .unwrap();
        }

        self.output.push_str("}\n\n");

        // Generate Encode method
        writeln!(self.output, "func (m *{}) Encode(buf *[]byte) {{", m.name.node).unwrap();

        for field in &m.fields {
            let field_name = to_pascal_case(&field.node.name.node);
            let index = field.node.index.node;

            if field.node.optional {
                writeln!(self.output, "\tif m.{} != nil {{", field_name).unwrap();
                self.encode_tagged_field(index, &format!("(*m.{})", field_name), &field.node.ty.node, 2);
                self.output.push_str("\t}\n");
            } else {
                self.encode_tagged_field(index, &format!("m.{}", field_name), &field.node.ty.node, 1);
            }
        }

        self.output.push_str("\tEncodeMessageEnd(buf)\n");
        self.output.push_str("}\n\n");

        // Generate Decode method
        writeln!(
            self.output,
            "func Decode{}(buf *[]byte) ({}, error) {{",
            m.name.node, m.name.node
        )
        .unwrap();
        writeln!(self.output, "\tvar result {}", m.name.node).unwrap();

        self.output.push_str("\tfor {\n");
        self.output
            .push_str("\t\tindex, wireType, hasMore, err := DecodeTag(buf)\n");
        writeln!(self.output, "\t\tif err != nil {{").unwrap();
        writeln!(self.output, "\t\t\treturn {}{{}}, err", m.name.node).unwrap();
        writeln!(self.output, "\t\t}}").unwrap();
        self.output.push_str("\t\tif !hasMore {\n\t\t\tbreak\n\t\t}\n\n");
        self.output.push_str("\t\tswitch index {\n");

        for field in &m.fields {
            let field_name = to_pascal_case(&field.node.name.node);
            let index = field.node.index.node;
            writeln!(self.output, "\t\tcase {}:", index).unwrap();
            self.decode_tagged_field(
                &format!("result.{}", field_name),
                &field.node.ty.node,
                3,
                field.node.optional,
                &m.name.node,
            );
        }

        self.output.push_str("\t\tdefault:\n");
        self.output
            .push_str("\t\t\tif err := SkipByWireType(wireType, buf); err != nil {\n");
        writeln!(self.output, "\t\t\t\treturn {}{{}}, err", m.name.node).unwrap();
        self.output.push_str("\t\t\t}\n");
        self.output.push_str("\t\t}\n");
        self.output.push_str("\t}\n");
        self.output.push_str("\treturn result, nil\n");
        self.output.push_str("}\n");

        // Generate custom JSON marshaling for messages with []uint8 fields
        self.gen_message_json_marshaling(m);
    }

    fn gen_message_json_marshaling(&mut self, m: &Message) {
        // Check if any field needs custom marshaling ([]uint8)
        let has_u8_array = m.fields.iter().any(|f| {
            matches!(&f.node.ty.node, Type::Array(inner) if matches!(&inner.node, Type::U8))
        });

        if !has_u8_array {
            return;
        }

        // Generate MarshalJSON to convert []uint8 to JSON array instead of base64 string
        writeln!(self.output, "\nfunc (m {}) MarshalJSON() ([]byte, error) {{", m.name.node).unwrap();
        writeln!(self.output, "\ttype Alias {}", m.name.node).unwrap();
        writeln!(self.output, "\taux := &struct {{").unwrap();

        for field in &m.fields {
            let field_name = to_pascal_case(&field.node.name.node);
            if let Type::Array(inner) = &field.node.ty.node {
                if matches!(&inner.node, Type::U8) {
                    let ty = if field.node.optional {
                        "*[]interface{}".to_string()
                    } else {
                        "[]interface{}".to_string()
                    };
                    writeln!(self.output, "\t\t{} {} `json:\"{}\"`", field_name, ty, &field.node.name.node).unwrap();
                }
            }
        }

        writeln!(self.output, "\t\t*Alias").unwrap();
        writeln!(self.output, "\t}}{{").unwrap();
        writeln!(self.output, "\t\tAlias: (*Alias)(&m),").unwrap();
        writeln!(self.output, "\t}}").unwrap();

        for field in &m.fields {
            let field_name = to_pascal_case(&field.node.name.node);
            if let Type::Array(inner) = &field.node.ty.node {
                if matches!(&inner.node, Type::U8) {
                    if field.node.optional {
                        writeln!(self.output, "\tif m.{} != nil {{", field_name).unwrap();
                        writeln!(self.output, "\t\tarr := make([]interface{{}}, len(*m.{}))", field_name).unwrap();
                        writeln!(self.output, "\t\tfor i, v := range *m.{} {{", field_name).unwrap();
                        writeln!(self.output, "\t\t\tarr[i] = v").unwrap();
                        writeln!(self.output, "\t\t}}").unwrap();
                        writeln!(self.output, "\t\taux.{} = &arr", field_name).unwrap();
                        writeln!(self.output, "\t}}").unwrap();
                    } else {
                        writeln!(self.output, "\taux.{} = make([]interface{{}}, len(m.{}))", field_name, field_name).unwrap();
                        writeln!(self.output, "\tfor i, v := range m.{} {{", field_name).unwrap();
                        writeln!(self.output, "\t\taux.{}[i] = v", field_name).unwrap();
                        writeln!(self.output, "\t}}").unwrap();
                    }
                }
            }
        }

        writeln!(self.output, "\treturn json.Marshal(aux)").unwrap();
        writeln!(self.output, "}}").unwrap();

        // Generate UnmarshalJSON
        writeln!(self.output, "\nfunc (m *{}) UnmarshalJSON(data []byte) error {{", m.name.node).unwrap();
        writeln!(self.output, "\ttype Alias {}", m.name.node).unwrap();
        writeln!(self.output, "\taux := &struct {{").unwrap();

        for field in &m.fields {
            let field_name = to_pascal_case(&field.node.name.node);
            if let Type::Array(inner) = &field.node.ty.node {
                if matches!(&inner.node, Type::U8) {
                    let ty = if field.node.optional {
                        "*[]interface{}".to_string()
                    } else {
                        "[]interface{}".to_string()
                    };
                    writeln!(self.output, "\t\t{} {} `json:\"{}\"`", field_name, ty, &field.node.name.node).unwrap();
                }
            }
        }

        writeln!(self.output, "\t\t*Alias").unwrap();
        writeln!(self.output, "\t}}{{").unwrap();
        writeln!(self.output, "\t\tAlias: (*Alias)(m),").unwrap();
        writeln!(self.output, "\t}}").unwrap();

        writeln!(self.output, "\tif err := json.Unmarshal(data, &aux); err != nil {{").unwrap();
        writeln!(self.output, "\t\treturn err").unwrap();
        writeln!(self.output, "\t}}").unwrap();

        for field in &m.fields {
            let field_name = to_pascal_case(&field.node.name.node);
            if let Type::Array(inner) = &field.node.ty.node {
                if matches!(&inner.node, Type::U8) {
                    if field.node.optional {
                        writeln!(self.output, "\tif aux.{} != nil {{", field_name).unwrap();
                        writeln!(self.output, "\t\tarr := make([]uint8, len(*aux.{}))", field_name).unwrap();
                        writeln!(self.output, "\t\tfor i, v := range *aux.{} {{", field_name).unwrap();
                        writeln!(self.output, "\t\t\tif f, ok := v.(float64); ok {{ arr[i] = uint8(f) }}").unwrap();
                        writeln!(self.output, "\t\t}}").unwrap();
                        writeln!(self.output, "\t\tm.{} = &arr", field_name).unwrap();
                        writeln!(self.output, "\t}}").unwrap();
                    } else {
                        writeln!(self.output, "\tif aux.{} != nil {{", field_name).unwrap();
                        writeln!(self.output, "\t\tm.{} = make([]uint8, len(aux.{}))", field_name, field_name).unwrap();
                        writeln!(self.output, "\t\tfor i, v := range aux.{} {{", field_name).unwrap();
                        writeln!(self.output, "\t\t\tif f, ok := v.(float64); ok {{ m.{}[i] = uint8(f) }}", field_name).unwrap();
                        writeln!(self.output, "\t\t}}").unwrap();
                        writeln!(self.output, "\t}}").unwrap();
                    }
                }
            }
        }

        writeln!(self.output, "\treturn nil").unwrap();
        writeln!(self.output, "}}").unwrap();
    }

    fn gen_enum(&mut self, e: &Enum) {
        writeln!(self.output, "type {} uint32\n", e.name.node).unwrap();

        self.output.push_str("const (\n");
        for variant in &e.variants {
            writeln!(
                self.output,
                "\t{}{} {} = {}",
                e.name.node,
                to_pascal_case(&variant.node.name.node),
                e.name.node,
                variant.node.index.node
            )
            .unwrap();
        }
        self.output.push_str(")\n\n");

        // Generate Encode method
        writeln!(self.output, "func (e {}) Encode(buf *[]byte) {{", e.name.node).unwrap();
        self.output.push_str("\tEncodeU32(uint32(e), buf)\n");
        self.output.push_str("}\n\n");

        // Generate Decode method
        writeln!(
            self.output,
            "func Decode{}(buf *[]byte) ({}, error) {{",
            e.name.node, e.name.node
        )
        .unwrap();
        self.output.push_str("\tv, err := DecodeU32(buf)\n");
        self.output.push_str("\tif err != nil {\n\t\treturn 0, err\n\t}\n");
        self.output.push_str("\tswitch v {\n");

        for variant in &e.variants {
            writeln!(self.output, "\tcase {}:", variant.node.index.node).unwrap();
            writeln!(
                self.output,
                "\t\treturn {}{}, nil",
                e.name.node,
                to_pascal_case(&variant.node.name.node)
            )
            .unwrap();
        }

        self.output.push_str("\tdefault:\n");
        self.output.push_str("\t\treturn 0, ErrUnknownEnumVariant\n");
        self.output.push_str("\t}\n");
        self.output.push_str("}\n\n");

        // Generate MarshalJSON method
        writeln!(self.output, "func (e {}) MarshalJSON() ([]byte, error) {{", e.name.node).unwrap();
        self.output.push_str("\tswitch e {\n");
        for variant in &e.variants {
            writeln!(
                self.output,
                "\tcase {}{}:",
                e.name.node,
                to_pascal_case(&variant.node.name.node)
            )
            .unwrap();
            writeln!(
                self.output,
                "\t\treturn []byte(\"\\\"{}\\\"\"), nil",
                variant.node.name.node
            )
            .unwrap();
        }
        self.output.push_str("\tdefault:\n");
        self.output.push_str("\t\treturn nil, ErrUnknownEnumVariant\n");
        self.output.push_str("\t}\n");
        self.output.push_str("}\n\n");

        // Generate UnmarshalJSON method
        writeln!(
            self.output,
            "func (e *{}) UnmarshalJSON(data []byte) error {{",
            e.name.node
        )
        .unwrap();
        self.output.push_str("\tvar s string\n");
        self.output
            .push_str("\tif err := json.Unmarshal(data, &s); err != nil {\n\t\treturn err\n\t}\n");
        self.output.push_str("\tswitch s {\n");
        for variant in &e.variants {
            writeln!(self.output, "\tcase \"{}\":", variant.node.name.node).unwrap();
            writeln!(
                self.output,
                "\t\t*e = {}{}",
                e.name.node,
                to_pascal_case(&variant.node.name.node)
            )
            .unwrap();
        }
        self.output.push_str("\tdefault:\n");
        self.output.push_str("\t\treturn ErrUnknownEnumVariant\n");
        self.output.push_str("\t}\n");
        self.output.push_str("\treturn nil\n");
        self.output.push_str("}\n");
    }

    fn gen_union(&mut self, u: &Union) {
        // Generate union type as interface
        writeln!(self.output, "type {} interface {{", u.name.node).unwrap();
        writeln!(self.output, "\tEncode(buf *[]byte)").unwrap();
        writeln!(self.output, "\tis{}()", u.name.node).unwrap();
        self.output.push_str("}\n\n");

        // Generate variant types
        for variant in &u.variants {
            let variant_name = format!("{}{}", u.name.node, to_pascal_case(&variant.node.name.node));

            if let Some(ref ty) = variant.node.ty {
                writeln!(self.output, "type {} struct {{", variant_name).unwrap();
                writeln!(self.output, "\tValue {}", self.go_type(&ty.node)).unwrap();
                self.output.push_str("}\n\n");
            } else {
                writeln!(self.output, "type {} struct {{}}\n", variant_name).unwrap();
            }

            // Implement interface marker
            writeln!(self.output, "func ({}) is{}() {{}}\n", variant_name, u.name.node).unwrap();

            // Encode method for variant
            writeln!(self.output, "func (v {}) Encode(buf *[]byte) {{", variant_name).unwrap();
            let index = variant.node.index.node;

            if let Some(ref ty) = variant.node.ty {
                let wire_type = self.wire_type(&ty.node);
                writeln!(self.output, "\tEncodeTag({}, {}, buf)", index, wire_type).unwrap();
                if wire_type == "WireBytes" {
                    self.output.push_str("\t// Encode length-delimited\n");
                    self.output.push_str("\tlengthBuf := []byte{}\n");
                    self.encode_value("v.Value", &ty.node, 1);
                    self.output.push_str("\tEncodeBytes(lengthBuf, buf)\n");
                } else {
                    self.encode_value("v.Value", &ty.node, 1);
                }
            } else {
                writeln!(self.output, "\tEncodeTag({}, WireUnit, buf)", index).unwrap();
            }

            self.output.push_str("}\n\n");
        }

        // Generate Decode function
        writeln!(
            self.output,
            "func Decode{}(buf *[]byte) ({}, error) {{",
            u.name.node, u.name.node
        )
        .unwrap();
        self.output.push_str("\tindex, _, _, err := DecodeTag(buf)\n");
        self.output.push_str("\tif err != nil {\n\t\treturn nil, err\n\t}\n\n");
        self.output.push_str("\tswitch index {\n");

        for variant in &u.variants {
            let variant_name = format!("{}{}", u.name.node, to_pascal_case(&variant.node.name.node));
            writeln!(self.output, "\tcase {}:", variant.node.index.node).unwrap();

            if let Some(ref ty) = variant.node.ty {
                self.output.push_str("\t\tvar value ");
                self.output.push_str(&self.go_type(&ty.node));
                self.output.push('\n');

                let wire_type = self.wire_type(&ty.node);
                if wire_type == "WireBytes" {
                    self.output.push_str("\t\tlength, err := DecodeLEB128(buf)\n");
                    self.output
                        .push_str("\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n");
                    self.output
                        .push_str("\t\t_ = length // TODO: use for bounds checking\n");
                }

                // For unions, we return nil on error (not a zero value)
                // So we pass "nil" as the parent_type, but since decode_value_inline
                // formats it as "{}{{}}", we need to handle this specially
                let tabs = "\t\t";
                let (decode_call, _) = self.decode_call(&ty.node);
                writeln!(self.output, "{}value, err = {}", tabs, decode_call).unwrap();
                writeln!(self.output, "{}if err != nil {{", tabs).unwrap();
                writeln!(self.output, "{}\treturn nil, err", tabs).unwrap();
                writeln!(self.output, "{}}}", tabs).unwrap();
                writeln!(
                    self.output,
                    "\t\treturn {}{{{}}}, nil",
                    variant_name,
                    if self.is_named_type(&ty.node) {
                        "value"
                    } else {
                        "Value: value"
                    }
                )
                .unwrap();
            } else {
                writeln!(self.output, "\t\treturn {}{{}}, nil", variant_name).unwrap();
            }
        }

        self.output.push_str("\tdefault:\n");
        self.output.push_str("\t\treturn nil, ErrUnknownUnionVariant\n");
        self.output.push_str("\t}\n");
        self.output.push_str("}\n\n");

        // Generate JSON marshaling for each variant
        for variant in &u.variants {
            let variant_name = format!("{}{}", u.name.node, to_pascal_case(&variant.node.name.node));
            let orig_name = &variant.node.name.node;

            // MarshalJSON
            writeln!(
                self.output,
                "func (v {}) MarshalJSON() ([]byte, error) {{",
                variant_name
            )
            .unwrap();
            if variant.node.ty.is_some() {
                writeln!(self.output, "\tm := map[string]interface{{}}{{").unwrap();
                writeln!(self.output, "\t\t\"$tag\": \"{}\",", orig_name).unwrap();
                writeln!(self.output, "\t\t\"$value\": v.Value,").unwrap();
                writeln!(self.output, "\t}}").unwrap();
                writeln!(self.output, "\treturn json.Marshal(m)").unwrap();
            } else {
                // Unit variant - marshal as just the string
                writeln!(self.output, "\treturn []byte(\"\\\"{}\\\"\"), nil", orig_name).unwrap();
            }
            writeln!(self.output, "}}\n").unwrap();
        }

        // Generate UnmarshalJSON wrapper
        writeln!(self.output, "// {}JSON is a wrapper for JSON unmarshaling", u.name.node).unwrap();
        writeln!(self.output, "type {}JSON struct {{", u.name.node).unwrap();
        writeln!(self.output, "\tTag string `json:\"$tag\"`").unwrap();
        writeln!(self.output, "\tValue json.RawMessage `json:\"$value\"`").unwrap();
        writeln!(self.output, "}}\n").unwrap();

        // Helper function to unmarshal union from JSON
        writeln!(
            self.output,
            "func Unmarshal{}JSON(data []byte) ({}, error) {{",
            u.name.node, u.name.node
        )
        .unwrap();
        writeln!(self.output, "\t// Try unit variant (just a string)").unwrap();
        writeln!(self.output, "\tvar tag string").unwrap();
        writeln!(self.output, "\tif err := json.Unmarshal(data, &tag); err == nil {{").unwrap();
        writeln!(self.output, "\t\tswitch tag {{").unwrap();
        for variant in &u.variants {
            if variant.node.ty.is_none() {
                let variant_name = format!("{}{}", u.name.node, to_pascal_case(&variant.node.name.node));
                writeln!(self.output, "\t\tcase \"{}\":", variant.node.name.node).unwrap();
                writeln!(self.output, "\t\t\treturn {}{{}}, nil", variant_name).unwrap();
            }
        }
        writeln!(self.output, "\t\t}}").unwrap();
        writeln!(self.output, "\t}}").unwrap();
        writeln!(self.output, "\t// Try tagged variant").unwrap();
        writeln!(self.output, "\tvar wrapper {}JSON", u.name.node).unwrap();
        writeln!(self.output, "\tif err := json.Unmarshal(data, &wrapper); err != nil {{").unwrap();
        writeln!(self.output, "\t\treturn nil, err").unwrap();
        writeln!(self.output, "\t}}").unwrap();
        writeln!(self.output, "\tswitch wrapper.Tag {{").unwrap();
        for variant in &u.variants {
            let variant_name = format!("{}{}", u.name.node, to_pascal_case(&variant.node.name.node));
            writeln!(self.output, "\tcase \"{}\":", variant.node.name.node).unwrap();
            if let Some(ref ty) = variant.node.ty {
                writeln!(self.output, "\t\tvar value {}", self.go_type(&ty.node)).unwrap();
                writeln!(
                    self.output,
                    "\t\tif err := json.Unmarshal(wrapper.Value, &value); err != nil {{"
                )
                .unwrap();
                writeln!(self.output, "\t\t\treturn nil, err").unwrap();
                writeln!(self.output, "\t\t}}").unwrap();
                writeln!(self.output, "\t\treturn {}{{Value: value}}, nil", variant_name).unwrap();
            } else {
                writeln!(self.output, "\t\treturn {}{{}}, nil", variant_name).unwrap();
            }
        }
        writeln!(self.output, "\tdefault:").unwrap();
        writeln!(self.output, "\t\treturn nil, ErrUnknownUnionVariant").unwrap();
        writeln!(self.output, "\t}}").unwrap();
        writeln!(self.output, "}}\n").unwrap();
    }

    fn encode_value(&mut self, value: &str, ty: &Type, indent: usize) {
        let tabs = "\t".repeat(indent);
        match ty {
            Type::Bool => writeln!(self.output, "{}EncodeBool({}, buf)", tabs, value).unwrap(),
            Type::U8 => writeln!(self.output, "{}EncodeU8({}, buf)", tabs, value).unwrap(),
            Type::U16 => writeln!(self.output, "{}EncodeU16({}, buf)", tabs, value).unwrap(),
            Type::U32 => writeln!(self.output, "{}EncodeU32({}, buf)", tabs, value).unwrap(),
            Type::U64 => writeln!(self.output, "{}EncodeU64({}, buf)", tabs, value).unwrap(),
            Type::I8 => writeln!(self.output, "{}EncodeI8({}, buf)", tabs, value).unwrap(),
            Type::I16 => writeln!(self.output, "{}EncodeI16({}, buf)", tabs, value).unwrap(),
            Type::I32 => writeln!(self.output, "{}EncodeI32({}, buf)", tabs, value).unwrap(),
            Type::I64 => writeln!(self.output, "{}EncodeI64({}, buf)", tabs, value).unwrap(),
            Type::F32 => writeln!(self.output, "{}EncodeF32({}, buf)", tabs, value).unwrap(),
            Type::F64 => writeln!(self.output, "{}EncodeF64({}, buf)", tabs, value).unwrap(),
            Type::String => writeln!(self.output, "{}EncodeString({}, buf)", tabs, value).unwrap(),
            Type::Array(inner) => {
                writeln!(self.output, "{}EncodeLEB128(uint64(len({})), buf)", tabs, value).unwrap();
                writeln!(self.output, "{}for _, item := range {} {{", tabs, value).unwrap();
                self.encode_value("item", &inner.node, indent + 1);
                writeln!(self.output, "{}}}", tabs).unwrap();
            }
            Type::Map(k, v) => {
                writeln!(self.output, "{}EncodeLEB128(uint64(len({})), buf)", tabs, value).unwrap();
                writeln!(self.output, "{}for k, v := range {} {{", tabs, value).unwrap();
                self.encode_value("k", &k.node, indent + 1);
                self.encode_value("v", &v.node, indent + 1);
                writeln!(self.output, "{}}}", tabs).unwrap();
            }
            Type::Named(name) => {
                if self.enum_names.contains(name) {
                    // Enums have a value receiver Encode method
                    writeln!(self.output, "{}{}.Encode(buf)", tabs, value).unwrap()
                } else if self.union_names.contains(name) {
                    // Unions are interfaces - just call Encode directly
                    writeln!(self.output, "{}{}.Encode(buf)", tabs, value).unwrap()
                } else {
                    // Structs/messages have pointer receiver Encode method
                    // We need to pass the address of the value
                    writeln!(self.output, "{}(&{}).Encode(buf)", tabs, value).unwrap()
                }
            }
        }
    }

    fn decode_value(&mut self, target: &str, ty: &Type, indent: usize, optional: bool, parent_type: &str) {
        let tabs = "\t".repeat(indent);

        // Arrays and maps need custom decoding logic
        match ty {
            Type::Array(inner) => {
                self.decode_array(target, &inner.node, indent, optional, parent_type);
                return;
            }
            Type::Map(k, v) => {
                self.decode_map(target, &k.node, &v.node, indent, optional, parent_type);
                return;
            }
            _ => {}
        }

        let (decode_call, _err_check) = self.decode_call(ty);

        if optional {
            writeln!(self.output, "{}var v {}", tabs, self.go_type(ty)).unwrap();
            writeln!(self.output, "{}v, err = {}", tabs, decode_call).unwrap();
            writeln!(self.output, "{}if err != nil {{", tabs).unwrap();
            writeln!(self.output, "{}\treturn {}{{}}, err", tabs, parent_type).unwrap();
            writeln!(self.output, "{}}}", tabs).unwrap();
            writeln!(self.output, "{}{} = &v", tabs, target).unwrap();
        } else {
            writeln!(self.output, "{}{}, err = {}", tabs, target, decode_call).unwrap();
            writeln!(self.output, "{}if err != nil {{", tabs).unwrap();
            writeln!(self.output, "{}\treturn {}{{}}, err", tabs, parent_type).unwrap();
            writeln!(self.output, "{}}}", tabs).unwrap();
        }
    }

    fn decode_array(&mut self, target: &str, elem_ty: &Type, indent: usize, optional: bool, parent_type: &str) {
        let tabs = "\t".repeat(indent);
        let elem_go_type = self.go_type(elem_ty);

        // Decode array length
        writeln!(self.output, "{}count, err := DecodeLEB128(buf)", tabs).unwrap();
        writeln!(self.output, "{}if err != nil {{", tabs).unwrap();
        writeln!(self.output, "{}\treturn {}{{}}, err", tabs, parent_type).unwrap();
        writeln!(self.output, "{}}}", tabs).unwrap();

        if optional {
            writeln!(self.output, "{}arr := make([]{}, count)", tabs, elem_go_type).unwrap();
        } else {
            writeln!(self.output, "{}{} = make([]{}, count)", tabs, target, elem_go_type).unwrap();
        }

        writeln!(self.output, "{}for i := uint64(0); i < count; i++ {{", tabs).unwrap();
        let item_target = if optional { "arr[i]" } else { &format!("{}[i]", target) };
        self.decode_value_inline(item_target, elem_ty, indent + 1, parent_type);
        writeln!(self.output, "{}}}", tabs).unwrap();

        if optional {
            writeln!(self.output, "{}{} = &arr", tabs, target).unwrap();
        }
    }

    fn decode_map(&mut self, target: &str, key_ty: &Type, val_ty: &Type, indent: usize, optional: bool, parent_type: &str) {
        let tabs = "\t".repeat(indent);
        let key_go_type = self.go_type(key_ty);
        let val_go_type = self.go_type(val_ty);

        // Decode map length
        writeln!(self.output, "{}count, err := DecodeLEB128(buf)", tabs).unwrap();
        writeln!(self.output, "{}if err != nil {{", tabs).unwrap();
        writeln!(self.output, "{}\treturn {}{{}}, err", tabs, parent_type).unwrap();
        writeln!(self.output, "{}}}", tabs).unwrap();

        if optional {
            writeln!(self.output, "{}m := make(map[{}]{}, count)", tabs, key_go_type, val_go_type).unwrap();
        } else {
            writeln!(self.output, "{}{} = make(map[{}]{}, count)", tabs, target, key_go_type, val_go_type).unwrap();
        }

        writeln!(self.output, "{}for i := uint64(0); i < count; i++ {{", tabs).unwrap();
        writeln!(self.output, "{}var k {}", tabs, key_go_type).unwrap();
        writeln!(self.output, "{}var v {}", tabs, val_go_type).unwrap();
        self.decode_value_inline("k", key_ty, indent + 1, parent_type);
        self.decode_value_inline("v", val_ty, indent + 1, parent_type);
        if optional {
            writeln!(self.output, "{}m[k] = v", tabs).unwrap();
        } else {
            writeln!(self.output, "{}{}[k] = v", tabs, target).unwrap();
        }
        writeln!(self.output, "{}}}", tabs).unwrap();

        if optional {
            writeln!(self.output, "{}{} = &m", tabs, target).unwrap();
        }
    }

    fn decode_value_inline(&mut self, target: &str, ty: &Type, indent: usize, parent_type: &str) {
        let tabs = "\t".repeat(indent);
        let (decode_call, _) = self.decode_call(ty);
        writeln!(self.output, "{}{}, err = {}", tabs, target, decode_call).unwrap();
        writeln!(self.output, "{}if err != nil {{", tabs).unwrap();
        writeln!(self.output, "{}\treturn {}{{}}, err", tabs, parent_type).unwrap();
        writeln!(self.output, "{}}}", tabs).unwrap();
    }

    fn decode_call(&self, ty: &Type) -> (String, bool) {
        match ty {
            Type::Bool => ("DecodeBool(buf)".to_string(), true),
            Type::U8 => ("DecodeU8(buf)".to_string(), true),
            Type::U16 => ("DecodeU16(buf)".to_string(), true),
            Type::U32 => ("DecodeU32(buf)".to_string(), true),
            Type::U64 => ("DecodeU64(buf)".to_string(), true),
            Type::I8 => ("DecodeI8(buf)".to_string(), true),
            Type::I16 => ("DecodeI16(buf)".to_string(), true),
            Type::I32 => ("DecodeI32(buf)".to_string(), true),
            Type::I64 => ("DecodeI64(buf)".to_string(), true),
            Type::F32 => ("DecodeF32(buf)".to_string(), true),
            Type::F64 => ("DecodeF64(buf)".to_string(), true),
            Type::String => ("DecodeString(buf)".to_string(), true),
            Type::Array(_) => ("nil, nil".to_string(), true), // TODO: implement array decode
            Type::Map(_, _) => ("nil, nil".to_string(), true), // TODO: implement map decode
            Type::Named(name) => (format!("Decode{}(buf)", name), true),
        }
    }

    fn encode_tagged_field(&mut self, index: u32, value: &str, ty: &Type, indent: usize) {
        let tabs = "\t".repeat(indent);
        let wire_type = self.wire_type(ty);
        writeln!(self.output, "{}EncodeTag({}, {}, buf)", tabs, index, wire_type).unwrap();

        if wire_type == "WireBytes" {
            // For length-delimited fields, we need to encode to a temp buffer,
            // then write the length, then the buffer
            writeln!(self.output, "{}{{", tabs).unwrap();
            writeln!(self.output, "{}\tlengthBuf := []byte{{}}", tabs).unwrap();
            writeln!(self.output, "{}\ttmpBuf := &lengthBuf", tabs).unwrap();
            self.encode_value_to_buf(value, ty, indent + 1, "tmpBuf");
            writeln!(self.output, "{}\tEncodeLEB128(uint64(len(lengthBuf)), buf)", tabs).unwrap();
            writeln!(self.output, "{}\t*buf = append(*buf, lengthBuf...)", tabs).unwrap();
            writeln!(self.output, "{}}}", tabs).unwrap();
        } else {
            self.encode_value(value, ty, indent);
        }
    }

    fn encode_value_to_buf(&mut self, value: &str, ty: &Type, indent: usize, buf_var: &str) {
        let tabs = "\t".repeat(indent);
        match ty {
            Type::Bool => writeln!(self.output, "{}EncodeBool({}, {})", tabs, value, buf_var).unwrap(),
            Type::U8 => writeln!(self.output, "{}EncodeU8({}, {})", tabs, value, buf_var).unwrap(),
            Type::U16 => writeln!(self.output, "{}EncodeU16({}, {})", tabs, value, buf_var).unwrap(),
            Type::U32 => writeln!(self.output, "{}EncodeU32({}, {})", tabs, value, buf_var).unwrap(),
            Type::U64 => writeln!(self.output, "{}EncodeU64({}, {})", tabs, value, buf_var).unwrap(),
            Type::I8 => writeln!(self.output, "{}EncodeI8({}, {})", tabs, value, buf_var).unwrap(),
            Type::I16 => writeln!(self.output, "{}EncodeI16({}, {})", tabs, value, buf_var).unwrap(),
            Type::I32 => writeln!(self.output, "{}EncodeI32({}, {})", tabs, value, buf_var).unwrap(),
            Type::I64 => writeln!(self.output, "{}EncodeI64({}, {})", tabs, value, buf_var).unwrap(),
            Type::F32 => writeln!(self.output, "{}EncodeF32({}, {})", tabs, value, buf_var).unwrap(),
            Type::F64 => writeln!(self.output, "{}EncodeF64({}, {})", tabs, value, buf_var).unwrap(),
            Type::String => writeln!(self.output, "{}EncodeString({}, {})", tabs, value, buf_var).unwrap(),
            Type::Array(inner) => {
                writeln!(self.output, "{}EncodeLEB128(uint64(len({})), {})", tabs, value, buf_var).unwrap();
                writeln!(self.output, "{}for _, item := range {} {{", tabs, value).unwrap();
                self.encode_value_to_buf("item", &inner.node, indent + 1, buf_var);
                writeln!(self.output, "{}}}", tabs).unwrap();
            }
            Type::Map(k, v) => {
                writeln!(self.output, "{}EncodeLEB128(uint64(len({})), {})", tabs, value, buf_var).unwrap();
                writeln!(self.output, "{}for k, v := range {} {{", tabs, value).unwrap();
                self.encode_value_to_buf("k", &k.node, indent + 1, buf_var);
                self.encode_value_to_buf("v", &v.node, indent + 1, buf_var);
                writeln!(self.output, "{}}}", tabs).unwrap();
            }
            Type::Named(name) => {
                if self.enum_names.contains(name) {
                    // Enums have a value receiver Encode method
                    writeln!(self.output, "{}{}.Encode({})", tabs, value, buf_var).unwrap()
                } else if self.union_names.contains(name) {
                    // Unions are interfaces - just call Encode directly
                    writeln!(self.output, "{}{}.Encode({})", tabs, value, buf_var).unwrap()
                } else {
                    // Structs/messages have pointer receiver Encode method
                    // We need to pass the address of the value
                    writeln!(self.output, "{}(&{}).Encode({})", tabs, value, buf_var).unwrap()
                }
            }
        }
    }

    fn decode_tagged_field(&mut self, target: &str, ty: &Type, indent: usize, optional: bool, parent_type: &str) {
        let tabs = "\t".repeat(indent);
        let wire_type = self.wire_type(ty);

        if wire_type == "WireBytes" {
            // For length-delimited fields, first decode the length
            writeln!(self.output, "{}length, err := DecodeLEB128(buf)", tabs).unwrap();
            writeln!(self.output, "{}if err != nil {{", tabs).unwrap();
            writeln!(self.output, "{}\treturn {}{{}}, err", tabs, parent_type).unwrap();
            writeln!(self.output, "{}}}", tabs).unwrap();
            writeln!(self.output, "{}_ = length // TODO: use for bounds checking", tabs).unwrap();
        }

        self.decode_value(target, ty, indent, optional, parent_type);
    }

    fn wire_type(&self, ty: &Type) -> &'static str {
        match ty {
            Type::Bool | Type::U8 | Type::I8 => "WireFixed8",
            Type::U16 | Type::U32 | Type::U64 | Type::I16 | Type::I32 | Type::I64 => "WireVarint",
            Type::F32 => "WireFixed32",
            Type::F64 => "WireFixed64",
            Type::String | Type::Array(_) | Type::Map(_, _) => "WireBytes",
            Type::Named(name) => {
                if self.enum_names.contains(name) {
                    "WireVarint" // Enums use VARINT
                } else {
                    "WireBytes" // Structs and messages use BYTES
                }
            }
        }
    }

    fn is_named_type(&self, ty: &Type) -> bool {
        matches!(ty, Type::Named(_))
    }
}

fn to_pascal_case(s: &str) -> String {
    s.split('_')
        .map(|word| {
            let mut chars = word.chars();
            match chars.next() {
                None => String::new(),
                Some(first) => first.to_uppercase().collect::<String>() + chars.as_str(),
            }
        })
        .collect()
}
