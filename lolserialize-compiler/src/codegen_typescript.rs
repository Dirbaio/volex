//! TypeScript code generator for lolserialize schemas.

use std::fmt::Write;

use crate::schema::*;

pub fn generate(schema: &Schema) -> String {
    let generator = TypeScriptCodeGenerator::new(schema);
    generator.generate()
}

struct TypeScriptCodeGenerator<'a> {
    schema: &'a Schema,
    output: String,
}

impl<'a> TypeScriptCodeGenerator<'a> {
    fn new(schema: &'a Schema) -> Self {
        Self {
            schema,
            output: String::new(),
        }
    }

    fn generate(mut self) -> String {
        self.output
            .push_str("// Code generated by lolserialize. DO NOT EDIT.\n\n");

        self.output
            .push_str("import * as __rt from \"./lolserialize-runtime.js\";\n\n");

        for item in &self.schema.items {
            match &item.node {
                Item::Struct(s) => self.gen_struct(s),
                Item::Message(m) => self.gen_message(m),
                Item::Enum(e) => self.gen_enum(e),
                Item::Union(u) => self.gen_union(u),
            }
            self.output.push('\n');
        }

        self.output
    }

    fn ts_type(&self, ty: &Type) -> String {
        match ty {
            Type::Bool => "boolean".to_string(),
            Type::U8
            | Type::U16
            | Type::U32
            | Type::U64
            | Type::I8
            | Type::I16
            | Type::I32
            | Type::I64
            | Type::F32
            | Type::F64 => "number".to_string(),
            Type::String => "string".to_string(),
            Type::Array(inner) => format!("{}[]", self.ts_type(&inner.node)),
            Type::Map(k, v) => format!("Map<{}, {}>", self.ts_type(&k.node), self.ts_type(&v.node)),
            Type::Named(name) => name.clone(),
        }
    }

    fn ts_type_optional(&self, ty: &Type) -> String {
        format!("{} | null", self.ts_type(ty))
    }

    fn gen_struct(&mut self, s: &Struct) {
        writeln!(self.output, "export interface {} {{", s.name.node).unwrap();

        for field in &s.fields {
            let ty = if field.optional {
                self.ts_type_optional(&field.ty.node)
            } else {
                self.ts_type(&field.ty.node)
            };
            writeln!(self.output, "  {}: {};", field.name.node, ty).unwrap();
        }

        self.output.push_str("}\n\n");

        // Generate encode function
        writeln!(
            self.output,
            "export function encode{}(value: {}, buf: Uint8Array[]): void {{",
            s.name.node, s.name.node
        )
        .unwrap();

        // Handle optional fields - encode presence bits first
        let optional_fields: Vec<_> = s.fields.iter().filter(|f| f.optional).collect();
        if !optional_fields.is_empty() {
            self.output.push_str("  const presence: boolean[] = [");
            for (i, field) in optional_fields.iter().enumerate() {
                if i > 0 {
                    self.output.push_str(", ");
                }
                write!(self.output, "value.{} !== null", &field.name.node).unwrap();
            }
            self.output.push_str("];\n");
            self.output.push_str("  __rt.encodePresenceBits(presence, buf);\n\n");
        }

        // Encode each field
        for field in &s.fields {
            let field_name = &field.name.node;
            if field.optional {
                writeln!(self.output, "  if (value.{} !== null) {{", field_name).unwrap();
                self.encode_value(&format!("value.{}", field_name), &field.ty.node, 2);
                self.output.push_str("  }\n");
            } else {
                self.encode_value(&format!("value.{}", field_name), &field.ty.node, 1);
            }
        }

        self.output.push_str("}\n\n");

        // Generate decode function
        writeln!(
            self.output,
            "export function decode{}(buf: __rt.Buf): {} {{",
            s.name.node, s.name.node
        )
        .unwrap();

        // Handle optional fields - decode presence bits first
        if !optional_fields.is_empty() {
            writeln!(
                self.output,
                "  const presence = __rt.decodePresenceBits(buf, {});",
                optional_fields.len()
            )
            .unwrap();
            self.output.push('\n');
        }

        // Decode each field
        let mut presence_idx = 0;
        for field in &s.fields {
            let field_name = &field.name.node;
            if field.optional {
                writeln!(
                    self.output,
                    "  let {}: {} | null = null;",
                    field_name,
                    self.ts_type(&field.ty.node)
                )
                .unwrap();
                writeln!(self.output, "  if (presence[{}]) {{", presence_idx).unwrap();
                self.decode_value(&field_name, &field.ty.node, 2);
                self.output.push_str("  }\n");
                presence_idx += 1;
            } else {
                write!(
                    self.output,
                    "  const {}: {} = ",
                    field_name,
                    self.ts_type(&field.ty.node)
                )
                .unwrap();
                self.decode_value_inline(&field.ty.node);
                self.output.push_str(";\n");
            }
        }

        self.output.push_str("\n  return {");
        for (i, field) in s.fields.iter().enumerate() {
            if i > 0 {
                self.output.push_str(", ");
            }
            write!(self.output, "{}", &field.name.node).unwrap();
        }
        self.output.push_str("};\n");
        self.output.push_str("}\n");
    }

    fn gen_message(&mut self, m: &Message) {
        writeln!(self.output, "export interface {} {{", m.name.node).unwrap();

        for field in &m.fields {
            let ty = if field.optional {
                self.ts_type_optional(&field.ty.node)
            } else {
                self.ts_type(&field.ty.node)
            };
            writeln!(self.output, "  {}: {};", &field.name.node, ty).unwrap();
        }

        self.output.push_str("}\n\n");

        // Generate encode function
        writeln!(
            self.output,
            "export function encode{}(value: {}, buf: Uint8Array[]): void {{",
            m.name.node, m.name.node
        )
        .unwrap();

        // Sort fields by index for encoding in index order
        let mut sorted_fields: Vec<_> = m.fields.iter().collect();
        sorted_fields.sort_by_key(|f| f.index.node);

        for field in sorted_fields {
            let field_name = &field.name.node;
            let index = field.index.node;

            if field.optional {
                writeln!(self.output, "  if (value.{} !== null) {{", field_name).unwrap();
                self.encode_tagged_field(index, &format!("value.{}", field_name), &field.ty.node, 2);
                self.output.push_str("  }\n");
            } else {
                self.encode_tagged_field(index, &format!("value.{}", field_name), &field.ty.node, 1);
            }
        }

        self.output.push_str("  __rt.encodeTag(0, 0, buf);\n");
        self.output.push_str("}\n\n");

        // Generate decode function
        writeln!(
            self.output,
            "export function decode{}(buf: __rt.Buf): {} {{",
            m.name.node, m.name.node
        )
        .unwrap();

        // Declare all fields with null/default values
        for field in &m.fields {
            let field_name = &field.name.node;
            if field.optional {
                writeln!(
                    self.output,
                    "  let {}: {} | null = null;",
                    field_name,
                    self.ts_type(&field.ty.node)
                )
                .unwrap();
            } else {
                write!(self.output, "  let {}: {} = ", field_name, self.ts_type(&field.ty.node)).unwrap();
                self.write_default_value(&field.ty.node);
                self.output.push_str(";\n");
            }
        }

        self.output.push_str("\n  while (true) {\n");
        self.output
            .push_str("    const { index, wireType } = __rt.decodeTag(buf);\n");
        self.output.push_str("    if (index === 0) break;\n\n");
        self.output.push_str("    switch (index) {\n");

        for field in &m.fields {
            let field_name = &field.name.node;
            let index = field.index.node;
            writeln!(self.output, "      case {}: {{", index).unwrap();
            self.decode_tagged_field(&field_name, &field.ty.node, 4);
            self.output.push_str("        break;\n");
            self.output.push_str("      }\n");
        }

        self.output.push_str("      default:\n");
        self.output.push_str("        // Skip unknown field\n");
        self.output
            .push_str("        throw new Error(`Unknown field index ${index}`);\n");
        self.output.push_str("    }\n");
        self.output.push_str("  }\n");

        self.output.push_str("\n  return {");
        for (i, field) in m.fields.iter().enumerate() {
            if i > 0 {
                self.output.push_str(", ");
            }
            write!(self.output, "{}", &field.name.node).unwrap();
        }
        self.output.push_str("};\n");
        self.output.push_str("}\n");
    }

    fn gen_enum(&mut self, e: &Enum) {
        // Generate TypeScript union type
        write!(self.output, "export type {} = ", e.name.node).unwrap();
        for (i, variant) in e.variants.iter().enumerate() {
            if i > 0 {
                self.output.push_str(" | ");
            }
            write!(self.output, "\"{}\"", variant.name.node).unwrap();
        }
        self.output.push_str(";\n\n");

        // Generate encode function
        writeln!(
            self.output,
            "export function encode{}(value: {}, buf: Uint8Array[]): void {{",
            e.name.node, e.name.node
        )
        .unwrap();
        self.output.push_str("  switch (value) {\n");
        for variant in &e.variants {
            writeln!(self.output, "    case \"{}\":", variant.name.node).unwrap();
            writeln!(self.output, "      __rt.encodeU32({}, buf);", variant.index.node).unwrap();
            writeln!(self.output, "      break;").unwrap();
        }
        self.output.push_str("    default:\n");
        self.output
            .push_str("      throw new Error(`Unknown enum variant: ${value}`);\n");
        self.output.push_str("  }\n");
        self.output.push_str("}\n\n");

        // Generate decode function
        writeln!(
            self.output,
            "export function decode{}(buf: __rt.Buf): {} {{",
            e.name.node, e.name.node
        )
        .unwrap();
        self.output.push_str("  const v = __rt.decodeU32(buf);\n");
        self.output.push_str("  switch (v) {\n");
        for variant in &e.variants {
            writeln!(self.output, "    case {}:", variant.index.node).unwrap();
            writeln!(self.output, "      return \"{}\";", variant.name.node).unwrap();
        }
        self.output.push_str("    default:\n");
        self.output
            .push_str("      throw new Error(`Unknown enum variant: ${v}`);\n");
        self.output.push_str("  }\n");
        self.output.push_str("}\n");
    }

    fn gen_union(&mut self, u: &Union) {
        let union_name = &u.name.node;

        // Generate TypeScript discriminated union type
        write!(self.output, "export type {} = ", union_name).unwrap();
        for (i, variant) in u.variants.iter().enumerate() {
            if i > 0 {
                self.output.push_str(" | ");
            }
            if let Some(ref ty) = variant.ty {
                write!(
                    self.output,
                    "{{ $tag: \"{}\"; $value: {} }}",
                    variant.name.node,
                    self.ts_type(&ty.node)
                )
                .unwrap();
            } else {
                write!(self.output, "{{ $tag: \"{}\" }}", variant.name.node).unwrap();
            }
        }
        self.output.push_str(";\n\n");

        // Generate encode function
        writeln!(
            self.output,
            "export function encode{}(value: {}, buf: Uint8Array[]): void {{",
            union_name, union_name
        )
        .unwrap();
        self.output.push_str("  switch (value.$tag) {\n");

        for variant in &u.variants {
            let index = variant.index.node;
            writeln!(self.output, "    case \"{}\":", variant.name.node).unwrap();

            if let Some(ref ty) = variant.ty {
                self.encode_tagged_field(index, "(value as any).$value", &ty.node, 3);
            } else {
                writeln!(self.output, "      __rt.encodeTag({}, 7, buf);", index).unwrap();
            }
            writeln!(self.output, "      break;").unwrap();
        }

        self.output.push_str("    default:\n");
        self.output
            .push_str("      throw new Error(`Unknown union variant: ${value.$tag}`);\n");
        self.output.push_str("  }\n");
        self.output.push_str("}\n\n");

        // Generate decode function
        writeln!(
            self.output,
            "export function decode{}(buf: __rt.Buf): {} {{",
            union_name, union_name
        )
        .unwrap();
        self.output
            .push_str("  const { index, wireType } = __rt.decodeTag(buf);\n");
        self.output.push_str("  switch (index) {\n");

        for variant in &u.variants {
            let index = variant.index.node;
            writeln!(self.output, "    case {}: {{", index).unwrap();

            if let Some(ref ty) = variant.ty {
                // Reuse decode_tagged_field logic which handles all wire types correctly
                write!(self.output, "      let value: {};", self.ts_type(&ty.node)).unwrap();
                self.output.push_str("\n");
                self.decode_tagged_field("value", &ty.node, 3);
                writeln!(
                    self.output,
                    "      return {{ $tag: \"{}\", $value: value }};",
                    variant.name.node
                )
                .unwrap();
            } else {
                writeln!(self.output, "      return {{ $tag: \"{}\" }};", variant.name.node).unwrap();
            }
            writeln!(self.output, "    }}").unwrap();
        }

        self.output.push_str("    default:\n");
        self.output
            .push_str("      throw new Error(`Unknown union variant: ${index}`);\n");
        self.output.push_str("  }\n");
        self.output.push_str("}\n");
    }

    fn encode_value(&mut self, value: &str, ty: &Type, indent: usize) {
        let spaces = "  ".repeat(indent);
        match ty {
            Type::Bool => writeln!(self.output, "{}__rt.encodeBool({}, buf);", spaces, value).unwrap(),
            Type::U8 => writeln!(self.output, "{}__rt.encodeU8({}, buf);", spaces, value).unwrap(),
            Type::U16 => writeln!(self.output, "{}__rt.encodeU16({}, buf);", spaces, value).unwrap(),
            Type::U32 => writeln!(self.output, "{}__rt.encodeU32({}, buf);", spaces, value).unwrap(),
            Type::U64 => writeln!(self.output, "{}__rt.encodeU64({}, buf);", spaces, value).unwrap(),
            Type::I8 => writeln!(self.output, "{}__rt.encodeI8({}, buf);", spaces, value).unwrap(),
            Type::I16 => writeln!(self.output, "{}__rt.encodeI16({}, buf);", spaces, value).unwrap(),
            Type::I32 => writeln!(self.output, "{}__rt.encodeI32({}, buf);", spaces, value).unwrap(),
            Type::I64 => writeln!(self.output, "{}__rt.encodeI64({}, buf);", spaces, value).unwrap(),
            Type::F32 => writeln!(self.output, "{}__rt.encodeF32({}, buf);", spaces, value).unwrap(),
            Type::F64 => writeln!(self.output, "{}__rt.encodeF64({}, buf);", spaces, value).unwrap(),
            Type::String => writeln!(self.output, "{}__rt.encodeString({}, buf);", spaces, value).unwrap(),
            Type::Array(inner) => {
                writeln!(self.output, "{}__rt.encodeVarint({}.length, buf);", spaces, value).unwrap();
                writeln!(self.output, "{}for (const item of {}) {{", spaces, value).unwrap();
                self.encode_value("item", &inner.node, indent + 1);
                writeln!(self.output, "{}}}", spaces).unwrap();
            }
            Type::Map(k, v) => {
                writeln!(self.output, "{}__rt.encodeVarint({}.size, buf);", spaces, value).unwrap();
                writeln!(self.output, "{}for (const [k, v] of {}) {{", spaces, value).unwrap();
                self.encode_value("k", &k.node, indent + 1);
                self.encode_value("v", &v.node, indent + 1);
                writeln!(self.output, "{}}}", spaces).unwrap();
            }
            Type::Named(name) => {
                writeln!(self.output, "{}encode{}({}, buf);", spaces, name, value).unwrap();
            }
        }
    }

    fn decode_value(&mut self, target: &str, ty: &Type, indent: usize) {
        let spaces = "  ".repeat(indent);
        write!(self.output, "{}{} = ", spaces, target).unwrap();
        self.decode_value_inline(ty);
        self.output.push_str(";\n");
    }

    fn decode_value_inline(&mut self, ty: &Type) {
        match ty {
            Type::Bool => write!(self.output, "__rt.decodeBool(buf)").unwrap(),
            Type::U8 => write!(self.output, "__rt.decodeU8(buf)").unwrap(),
            Type::U16 => write!(self.output, "__rt.decodeU16(buf)").unwrap(),
            Type::U32 => write!(self.output, "__rt.decodeU32(buf)").unwrap(),
            Type::U64 => write!(self.output, "__rt.decodeU64(buf)").unwrap(),
            Type::I8 => write!(self.output, "__rt.decodeI8(buf)").unwrap(),
            Type::I16 => write!(self.output, "__rt.decodeI16(buf)").unwrap(),
            Type::I32 => write!(self.output, "__rt.decodeI32(buf)").unwrap(),
            Type::I64 => write!(self.output, "__rt.decodeI64(buf)").unwrap(),
            Type::F32 => write!(self.output, "__rt.decodeF32(buf)").unwrap(),
            Type::F64 => write!(self.output, "__rt.decodeF64(buf)").unwrap(),
            Type::String => write!(self.output, "__rt.decodeString(buf)").unwrap(),
            Type::Array(inner) => {
                write!(self.output, "(() => {{ const count = Number(__rt.decodeVarint(buf)); const arr: {}[] = []; for (let i = 0; i < count; i++) {{ arr.push(", self.ts_type(&inner.node)).unwrap();
                self.decode_value_inline(&inner.node);
                write!(self.output, "); }} return arr; }})()").unwrap();
            }
            Type::Map(k, v) => {
                write!(
                    self.output,
                    "(() => {{ const count = Number(__rt.decodeVarint(buf)); const map = new Map<{}, {}>(); for (let i = 0; i < count; i++) {{ const k = ",
                    self.ts_type(&k.node),
                    self.ts_type(&v.node)
                )
                .unwrap();
                self.decode_value_inline(&k.node);
                write!(self.output, "; const v = ").unwrap();
                self.decode_value_inline(&v.node);
                write!(self.output, "; map.set(k, v); }} return map; }})()").unwrap();
            }
            Type::Named(name) => {
                write!(self.output, "decode{}(buf)", name).unwrap();
            }
        }
    }

    fn decode_value_inline_with_buf(&mut self, ty: &Type, buf_name: &str) {
        match ty {
            Type::Bool => write!(self.output, "__rt.decodeBool({})", buf_name).unwrap(),
            Type::U8 => write!(self.output, "__rt.decodeU8({})", buf_name).unwrap(),
            Type::U16 => write!(self.output, "__rt.decodeU16({})", buf_name).unwrap(),
            Type::U32 => write!(self.output, "__rt.decodeU32({})", buf_name).unwrap(),
            Type::U64 => write!(self.output, "__rt.decodeU64({})", buf_name).unwrap(),
            Type::I8 => write!(self.output, "__rt.decodeI8({})", buf_name).unwrap(),
            Type::I16 => write!(self.output, "__rt.decodeI16({})", buf_name).unwrap(),
            Type::I32 => write!(self.output, "__rt.decodeI32({})", buf_name).unwrap(),
            Type::I64 => write!(self.output, "__rt.decodeI64({})", buf_name).unwrap(),
            Type::F32 => write!(self.output, "__rt.decodeF32({})", buf_name).unwrap(),
            Type::F64 => write!(self.output, "__rt.decodeF64({})", buf_name).unwrap(),
            Type::String => write!(self.output, "__rt.decodeString({})", buf_name).unwrap(),
            Type::Array(inner) => {
                write!(self.output, "(() => {{ const count = Number(__rt.decodeVarint({})); const arr: {}[] = []; for (let i = 0; i < count; i++) {{ arr.push(", buf_name, self.ts_type(&inner.node)).unwrap();
                self.decode_value_inline_with_buf(&inner.node, buf_name);
                write!(self.output, "); }} return arr; }})()").unwrap();
            }
            Type::Map(k, v) => {
                write!(
                    self.output,
                    "(() => {{ const count = Number(__rt.decodeVarint({})); const map = new Map<{}, {}>(); for (let i = 0; i < count; i++) {{ const k = ",
                    buf_name,
                    self.ts_type(&k.node),
                    self.ts_type(&v.node)
                )
                .unwrap();
                self.decode_value_inline_with_buf(&k.node, buf_name);
                write!(self.output, "; const v = ").unwrap();
                self.decode_value_inline_with_buf(&v.node, buf_name);
                write!(self.output, "; map.set(k, v); }} return map; }})()").unwrap();
            }
            Type::Named(name) => {
                write!(self.output, "decode{}({})", name, buf_name).unwrap();
            }
        }
    }

    fn encode_tagged_field(&mut self, index: u32, value: &str, ty: &Type, indent: usize) {
        let spaces = "  ".repeat(indent);
        let wire_type = self.wire_type(ty);
        writeln!(self.output, "{}__rt.encodeTag({}, {}, buf);", spaces, index, wire_type).unwrap();

        if wire_type == 4 {
            // WireBytes - need to encode to temp buffer first
            writeln!(self.output, "{}{{", spaces).unwrap();
            writeln!(self.output, "{}  const tmpBuf: Uint8Array[] = [];", spaces).unwrap();
            self.encode_value_to_buf(value, ty, indent + 1, "tmpBuf", true);
            writeln!(self.output, "{}  const bytes = __rt.flattenBuf(tmpBuf);", spaces).unwrap();
            writeln!(self.output, "{}  __rt.encodeVarint(bytes.length, buf);", spaces).unwrap();
            writeln!(self.output, "{}  buf.push(bytes);", spaces).unwrap();
            writeln!(self.output, "{}}}", spaces).unwrap();
        } else {
            self.encode_value(value, ty, indent);
        }
    }

    fn encode_value_to_buf(&mut self, value: &str, ty: &Type, indent: usize, buf_var: &str, in_bytes_field: bool) {
        let spaces = "  ".repeat(indent);
        match ty {
            Type::Bool => writeln!(self.output, "{}__rt.encodeBool({}, {});", spaces, value, buf_var).unwrap(),
            Type::U8 => writeln!(self.output, "{}__rt.encodeU8({}, {});", spaces, value, buf_var).unwrap(),
            Type::U16 => writeln!(self.output, "{}__rt.encodeU16({}, {});", spaces, value, buf_var).unwrap(),
            Type::U32 => writeln!(self.output, "{}__rt.encodeU32({}, {});", spaces, value, buf_var).unwrap(),
            Type::U64 => writeln!(self.output, "{}__rt.encodeU64({}, {});", spaces, value, buf_var).unwrap(),
            Type::I8 => writeln!(self.output, "{}__rt.encodeI8({}, {});", spaces, value, buf_var).unwrap(),
            Type::I16 => writeln!(self.output, "{}__rt.encodeI16({}, {});", spaces, value, buf_var).unwrap(),
            Type::I32 => writeln!(self.output, "{}__rt.encodeI32({}, {});", spaces, value, buf_var).unwrap(),
            Type::I64 => writeln!(self.output, "{}__rt.encodeI64({}, {});", spaces, value, buf_var).unwrap(),
            Type::F32 => writeln!(self.output, "{}__rt.encodeF32({}, {});", spaces, value, buf_var).unwrap(),
            Type::F64 => writeln!(self.output, "{}__rt.encodeF64({}, {});", spaces, value, buf_var).unwrap(),
            Type::String => {
                if in_bytes_field {
                    writeln!(
                        self.output,
                        "{}{}.push(new TextEncoder().encode({}));",
                        spaces, buf_var, value
                    )
                    .unwrap();
                } else {
                    writeln!(self.output, "{}__rt.encodeString({}, {});", spaces, value, buf_var).unwrap();
                }
            }
            Type::Array(inner) => {
                if self.schema.fixed_size(&inner.node).is_some() {
                    writeln!(self.output, "{}for (const item of {}) {{", spaces, value).unwrap();
                    self.encode_value_to_buf("item", &inner.node, indent + 1, buf_var, false);
                    writeln!(self.output, "{}}}", spaces).unwrap();
                } else {
                    writeln!(
                        self.output,
                        "{}__rt.encodeVarint({}.length, {});",
                        spaces, value, buf_var
                    )
                    .unwrap();
                    writeln!(self.output, "{}for (const item of {}) {{", spaces, value).unwrap();
                    self.encode_value_to_buf("item", &inner.node, indent + 1, buf_var, false);
                    writeln!(self.output, "{}}}", spaces).unwrap();
                }
            }
            Type::Map(k, v) => {
                let key_fixed = self.schema.fixed_size(&k.node).is_some();
                let val_fixed = self.schema.fixed_size(&v.node).is_some();
                if key_fixed && val_fixed {
                    writeln!(self.output, "{}for (const [k, v] of {}) {{", spaces, value).unwrap();
                    self.encode_value_to_buf("k", &k.node, indent + 1, buf_var, false);
                    self.encode_value_to_buf("v", &v.node, indent + 1, buf_var, false);
                    writeln!(self.output, "{}}}", spaces).unwrap();
                } else {
                    writeln!(self.output, "{}__rt.encodeVarint({}.size, {});", spaces, value, buf_var).unwrap();
                    writeln!(self.output, "{}for (const [k, v] of {}) {{", spaces, value).unwrap();
                    self.encode_value_to_buf("k", &k.node, indent + 1, buf_var, false);
                    self.encode_value_to_buf("v", &v.node, indent + 1, buf_var, false);
                    writeln!(self.output, "{}}}", spaces).unwrap();
                }
            }
            Type::Named(name) => {
                writeln!(self.output, "{}encode{}({}, {});", spaces, name, value, buf_var).unwrap();
            }
        }
    }

    fn decode_tagged_field(&mut self, target: &str, ty: &Type, indent: usize) {
        let spaces = "  ".repeat(indent);
        let wire_type = self.wire_type(ty);

        if wire_type == 4 {
            // WireBytes - need to decode length first
            writeln!(self.output, "{}const length = Number(__rt.decodeVarint(buf));", spaces).unwrap();

            match ty {
                Type::String => {
                    // Length already read, decode the string bytes directly
                    writeln!(
                        self.output,
                        "{}const strBytes = buf.data.slice(buf.offset, buf.offset + length);",
                        spaces
                    )
                    .unwrap();
                    writeln!(self.output, "{}buf.offset += length;", spaces).unwrap();
                    writeln!(
                        self.output,
                        "{}{} = new TextDecoder().decode(strBytes);",
                        spaces, target
                    )
                    .unwrap();
                    return;
                }
                Type::Array(inner) => {
                    if let Some(elem_size) = self.schema.fixed_size(&inner.node) {
                        // Fixed-size elements
                        writeln!(self.output, "{}const count = length / {};", spaces, elem_size).unwrap();
                        writeln!(self.output, "{}{} = [];", spaces, target).unwrap();
                        writeln!(self.output, "{}for (let i = 0; i < count; i++) {{", spaces).unwrap();
                        write!(self.output, "{}  {}.push(", spaces, target).unwrap();
                        self.decode_value_inline(&inner.node);
                        writeln!(self.output, ");").unwrap();
                        writeln!(self.output, "{}}}", spaces).unwrap();
                        return;
                    } else {
                        // Variable-size elements
                        writeln!(
                            self.output,
                            "{}const arrCount = Number(__rt.decodeVarint(buf));",
                            spaces
                        )
                        .unwrap();
                        writeln!(self.output, "{}{} = [];", spaces, target).unwrap();
                        writeln!(self.output, "{}for (let i = 0; i < arrCount; i++) {{", spaces).unwrap();
                        write!(self.output, "{}  {}.push(", spaces, target).unwrap();
                        self.decode_value_inline(&inner.node);
                        writeln!(self.output, ");").unwrap();
                        writeln!(self.output, "{}}}", spaces).unwrap();
                        return;
                    }
                }
                Type::Map(k, v) => {
                    let key_fixed = self.schema.fixed_size(&k.node).is_some();
                    let val_fixed = self.schema.fixed_size(&v.node).is_some();

                    if key_fixed && val_fixed {
                        let key_size = self.schema.fixed_size(&k.node).unwrap();
                        let val_size = self.schema.fixed_size(&v.node).unwrap();
                        let entry_size = key_size + val_size;
                        writeln!(self.output, "{}const count = length / {};", spaces, entry_size).unwrap();
                        writeln!(self.output, "{}{} = new Map();", spaces, target).unwrap();
                        writeln!(self.output, "{}for (let i = 0; i < count; i++) {{", spaces).unwrap();
                        write!(self.output, "{}  const k = ", spaces).unwrap();
                        self.decode_value_inline(&k.node);
                        writeln!(self.output, ";").unwrap();
                        write!(self.output, "{}  const v = ", spaces).unwrap();
                        self.decode_value_inline(&v.node);
                        writeln!(self.output, ";").unwrap();
                        writeln!(self.output, "{}  {}.set(k, v);", spaces, target).unwrap();
                        writeln!(self.output, "{}}}", spaces).unwrap();
                        return;
                    } else {
                        writeln!(
                            self.output,
                            "{}const mapCount = Number(__rt.decodeVarint(buf));",
                            spaces
                        )
                        .unwrap();
                        writeln!(self.output, "{}{} = new Map();", spaces, target).unwrap();
                        writeln!(self.output, "{}for (let i = 0; i < mapCount; i++) {{", spaces).unwrap();
                        write!(self.output, "{}  const k = ", spaces).unwrap();
                        self.decode_value_inline(&k.node);
                        writeln!(self.output, ";").unwrap();
                        write!(self.output, "{}  const v = ", spaces).unwrap();
                        self.decode_value_inline(&v.node);
                        writeln!(self.output, ";").unwrap();
                        writeln!(self.output, "{}  {}.set(k, v);", spaces, target).unwrap();
                        writeln!(self.output, "{}}}", spaces).unwrap();
                        return;
                    }
                }
                _ => {}
            }
        }

        self.decode_value(target, ty, indent);
    }

    fn wire_type(&self, ty: &Type) -> u8 {
        match self.schema.wire_type(ty) {
            crate::schema::WireType::Fixed8 => 0,
            crate::schema::WireType::Varint => 1,
            crate::schema::WireType::Fixed32 => 2,
            crate::schema::WireType::Fixed64 => 3,
            crate::schema::WireType::Bytes => 4,
            crate::schema::WireType::Message => 5,
            crate::schema::WireType::Union => 6,
            crate::schema::WireType::Unit => 7,
        }
    }

    fn write_default_value(&mut self, ty: &Type) {
        match ty {
            Type::Bool => write!(self.output, "false").unwrap(),
            Type::U8 | Type::U16 | Type::U32 | Type::I8 | Type::I16 | Type::I32 | Type::F32 | Type::F64 => {
                write!(self.output, "0").unwrap()
            }
            Type::U64 | Type::I64 => write!(self.output, "0n").unwrap(),
            Type::String => write!(self.output, "\"\"").unwrap(),
            Type::Array(_) => write!(self.output, "[]").unwrap(),
            Type::Map(_, _) => write!(self.output, "new Map()").unwrap(),
            Type::Named(_) => write!(self.output, "null as any").unwrap(),
        }
    }
}
